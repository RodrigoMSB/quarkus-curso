# ═══════════════════════════════════════════════════════════════
# APPLICATION.PROPERTIES - Configuración de Quarkus
# ═══════════════════════════════════════════════════════════════
#
# Archivo de configuración principal de la aplicación Quarkus.
#
# FORMATO:
# clave=valor
# - Sin espacios alrededor del =
# - Comentarios con #
# - Case-sensitive
#
# PRECEDENCIA (de menor a mayor prioridad):
# 1. application.properties (este archivo)
# 2. Variables de entorno (QUARKUS_HTTP_PORT=8081)
# 3. System properties (-Dquarkus.http.port=8081)
# 4. @ConfigProperty en código
#
# PERFILES (environment-specific):
# - %dev: Solo en desarrollo (./mvnw quarkus:dev)
# - %test: Solo en tests (./mvnw test)
# - %prod: Solo en producción (java -jar app.jar)
#
# Ejemplo de uso de perfiles:
# quarkus.http.port=8080              # Todos los perfiles
# %dev.quarkus.http.port=8080         # Solo desarrollo
# %prod.quarkus.http.port=80          # Solo producción
#
# DOCUMENTACIÓN COMPLETA:
# https://quarkus.io/guides/all-config
#
# ═══════════════════════════════════════════════════════════════

# ===================================
# CONFIGURACIÓN BASE DE LA APLICACIÓN
# ===================================

# Nombre de la aplicación
# Usado en:
# - Logs y trazabilidad
# - Métricas (Prometheus, Micrometer)
# - Health checks
# - Service discovery
# - Documentación OpenAPI
#
# Aparece en:
# - Swagger UI (título de la API)
# - Logs: [prestamos-service] ...
# - Métricas: application_info{name="prestamos-service"}
quarkus.application.name=prestamos-service

# Puerto HTTP en el que escucha la aplicación
# Default: 8080
#
# URLs resultantes:
# - Aplicación: http://localhost:8080
# - Swagger UI: http://localhost:8080/q/swagger-ui
# - Health: http://localhost:8080/q/health
# - Dev UI: http://localhost:8080/q/dev
#
# Si puerto ocupado:
# - Cambiar a 8081, 8082, etc.
# - Matar proceso: lsof -ti:8080 | xargs kill -9 (macOS/Linux)
#
# Variables de entorno (alternativa):
# export QUARKUS_HTTP_PORT=8081
# O: ./mvnw quarkus:dev -Dquarkus.http.port=8081
quarkus.http.port=8080

# ===================================
# CONFIGURACIÓN DE BASE DE DATOS
# ===================================

# Tipo de base de datos (JDBC driver)
# Opciones soportadas:
# - postgresql (usado aquí)
# - mysql, mariadb
# - h2 (en memoria, para tests)
# - oracle, mssql, db2
#
# Quarkus usa esto para:
# 1. Seleccionar driver JDBC correcto (org.postgresql.Driver)
# 2. Configurar Hibernate dialect (PostgreSQLDialect)
# 3. Generar SQL específico del motor
#
# Cambiar a H2 (sin instalación):
# quarkus.datasource.db-kind=h2
# quarkus.datasource.jdbc.url=jdbc:h2:mem:prestamos_db
quarkus.datasource.db-kind=postgresql

# Usuario de PostgreSQL
# En macOS: usuario del sistema (rodrigosilva)
# En Windows: generalmente 'postgres'
# En Linux: generalmente 'postgres'
#
# SEGURIDAD EN PRODUCCIÓN:
# ❌ NO hardcodear usuarios/passwords
# ✅ Usar variables de entorno:
#    export DB_USERNAME=mi_usuario
#    quarkus.datasource.username=${DB_USERNAME}
# ✅ Usar secrets managers:
#    - HashiCorp Vault
#    - AWS Secrets Manager
#    - Azure Key Vault
#
# Verificar usuario actual de PostgreSQL:
# psql -U rodrigosilva -d postgres -c "SELECT current_user;"
quarkus.datasource.username=rodrigosilva

# Contraseña de PostgreSQL
# (vacío) = sin contraseña (común en instalaciones locales macOS)
#
# IMPORTANTE:
# - PostgreSQL local en macOS: generalmente sin password
# - PostgreSQL en Windows/Linux: suele tener password
# - PostgreSQL en producción: SIEMPRE con password fuerte
#
# Configuración segura (producción):
# quarkus.datasource.password=${DB_PASSWORD:}
# - Lee variable DB_PASSWORD
# - Fallback a "" (vacío) si no existe
#
# NUNCA commitear passwords reales:
# - Agregar .env al .gitignore
# - Usar vault/secrets en CI/CD
quarkus.datasource.password=

# URL de conexión JDBC a PostgreSQL
# Formato: jdbc:postgresql://[host]:[puerto]/[database]
#
# Componentes:
# - jdbc:postgresql:// → Protocolo JDBC + driver PostgreSQL
# - localhost → Host (servidor de BD, misma máquina)
# - 5432 → Puerto default de PostgreSQL
# - postgres → Nombre de la base de datos
#
# ⚠️ NOTA: Se usa BD 'postgres' (default), no 'prestamos_db'
# Hibernate crea las tablas automáticamente con 'update'
#
# Alternativas:
# - Base de datos específica:
#   jdbc:postgresql://localhost:5432/prestamos_db
#
# - Servidor remoto:
#   jdbc:postgresql://192.168.1.100:5432/prestamos_db
#
# - Cloud (AWS RDS):
#   jdbc:postgresql://mydb.xxxxx.us-east-1.rds.amazonaws.com:5432/prestamos_db
#
# - Con SSL (producción):
#   jdbc:postgresql://localhost:5432/postgres?ssl=true&sslmode=require
#
# - Con timezone:
#   jdbc:postgresql://localhost:5432/postgres?currentSchema=public&TimeZone=America/Lima
#
# Verificar conexión manual:
# psql -h localhost -p 5432 -U rodrigosilva -d postgres
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/postgres

# ===================================
# HIBERNATE ORM - Persistencia JPA
# ===================================

# Estrategia de generación del schema de base de datos
#
# OPCIONES DISPONIBLES:
#
# ┌─────────────────┬──────────────┬─────────────┬──────────────┐
# │ Opción          │ Crea tablas  │ Borra datos │ Cuándo usar  │
# ├─────────────────┼──────────────┼─────────────┼──────────────┤
# │ none            │ NO           │ NO          │ Producción   │
# │ validate        │ NO           │ NO          │ Staging      │
# │ update          │ SÍ (nuevas)  │ NO          │ Desarrollo ✅│
# │ create          │ SÍ           │ NO          │ Rara vez     │
# │ drop-and-create │ SÍ           │ SÍ ⚠️       │ Demos        │
# │ create-drop     │ SÍ           │ SÍ (al fin) │ Tests        │
# └─────────────────┴──────────────┴─────────────┴──────────────┘
#
# update (RECOMENDADO PARA DESARROLLO):
# - Crea tablas si no existen (primera vez)
# - Agrega columnas nuevas (si modificas entidades)
# - NO elimina columnas (seguro)
# - NO modifica tipos existentes
# - PRESERVA datos entre reinicios ✅
# - Detecta cambios en @Entity y actualiza schema
#
# Ejemplo de flujo con 'update':
# 1. Primera ejecución:
#    → Crea: clientes, prestamos, cuotas
# 2. Agregas campo 'activo' a Cliente:
#    → ALTER TABLE clientes ADD COLUMN activo BOOLEAN
# 3. Reinicias:
#    → Datos intactos, columna 'activo' agregada
#
# PRODUCCIÓN (cambiar a):
# quarkus.hibernate-orm.database.generation=none
# + Usar Flyway o Liquibase para migraciones controladas
#
# TESTS (en application-test.properties):
# quarkus.hibernate-orm.database.generation=drop-and-create
# → Schema limpio en cada test
quarkus.hibernate-orm.database.generation=update

# Mostrar queries SQL en la consola
# true: Imprime TODAS las queries SQL ejecutadas
# false: No muestra SQL (producción)
#
# Output en consola cuando true:
# Hibernate: 
#     select
#         c1_0.id,
#         c1_0.dni,
#         c1_0.email,
#         c1_0.nombre,
#         c1_0.telefono 
#     from
#         clientes c1_0
#
# Hibernate: 
#     insert 
#     into
#         prestamos
#         (cliente_id, estado, fecha_desembolso, monto, plazo_meses, tasa_interes, id) 
#     values
#         (?, ?, ?, ?, ?, ?, default)
#
# ÚTIL PARA:
# ✅ Debugging (ver queries generadas)
# ✅ Optimización (detectar N+1 queries)
# ✅ Aprendizaje (entender JPA/Hibernate)
# ✅ Verificar índices usados
#
# DESACTIVAR EN PRODUCCIÓN:
# - Degrada performance (I/O a consola)
# - Logs muy verbosos
# - Información sensible en queries
#
# Alternativa (solo queries lentas):
# quarkus.hibernate-orm.log.sql=false
# quarkus.hibernate-orm.log.slow-query=true
# quarkus.hibernate-orm.slow-query-threshold=1000  # 1 segundo
quarkus.hibernate-orm.log.sql=true

# Script SQL de inicialización
# no-file: NO cargar script SQL al iniciar
#
# Por defecto, Hibernate busca:
# - src/main/resources/import.sql
# - src/main/resources/import-{db}.sql
#
# Si existe import.sql, lo ejecuta DESPUÉS de crear schema.
#
# Ejemplo import.sql (seed data):
# INSERT INTO clientes (id, nombre, dni, email, telefono) 
# VALUES (1, 'Juan Pérez', '12345678', 'juan@example.com', '987654321');
#
# INSERT INTO clientes (id, nombre, dni, email, telefono) 
# VALUES (2, 'María López', '87654321', 'maria@example.com', '999888777');
#
# Opciones:
# - no-file: No carga ningún script (actual) ✅
# - import.sql: Carga src/main/resources/import.sql
# - data.sql: Carga src/main/resources/data.sql
#
# ⚠️ Solo funciona con database.generation != none
#
# Alternativa para seed data:
# - @Startup bean con lógica de inicialización
# - Flyway migrations con datos
# - CommandLineRunner (Spring) / StartupEvent (Quarkus)
quarkus.hibernate-orm.sql-load-script=no-file

# ===================================
# CONFIGURACIÓN DE DESARROLLO
# ===================================

# Live Reload - Recarga automática de código
# true: Detecta cambios y recompila automáticamente
# false: Requiere reinicio manual
#
# Funciona con:
# ✅ Cambios en clases Java
# ✅ Cambios en application.properties
# ✅ Cambios en templates (Qute)
# ✅ Agregado de dependencias (pom.xml)
#
# Flujo:
# 1. Modificas archivo Java
# 2. Guardas (Ctrl+S / Cmd+S)
# 3. Quarkus detecta cambio
# 4. Recompila automáticamente
# 5. Refresca navegador → código actualizado ✅
#
# NO requiere:
# - Reiniciar servidor
# - Recompilar manualmente
# - Esperar build completo
#
# Performance:
# - Compilación incremental (solo cambios)
# - < 1 segundo típicamente
# - Hot reload inteligente
#
# Solo activo en modo dev:
# ./mvnw quarkus:dev
#
# Desactivar si causa problemas:
# quarkus.live-reload.instrumentation=false
quarkus.live-reload.instrumentation=true

# ===================================
# CONFIGURACIÓN DE LOGS
# ===================================

# Formato de logs en consola
# Patrón: %d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n
#
# TOKENS:
# %d{HH:mm:ss}     → Timestamp: 14:30:45
# %-5p             → Nivel log (5 chars, left-align): INFO , ERROR, DEBUG, WARN , TRACE
# [%c{2.}]         → Logger (2 segmentos): [pe.ba.pr.re.ClienteResource]
# (%t)             → Thread name: (executor-thread-1)
# %s               → Mensaje del log
# %e               → Exception stack trace (si hay)
# %n               → Nueva línea
#
# Output ejemplo:
# 14:30:45 INFO  [pe.ba.pr.re.ClienteResource] (executor-thread-1) Cliente creado: id=1
# 14:30:46 ERROR [pe.ba.pr.se.PrestamoService] (executor-thread-2) Error al crear préstamo
# java.lang.NullPointerException: cliente no puede ser null
#     at pe.banco.prestamos.service.PrestamoService.crear(PrestamoService.java:45)
#     ...
#
# Formatos alternativos:
# - Simple: %d{HH:mm:ss} %p %s%e%n
# - Completo: %d{yyyy-MM-dd HH:mm:ss.SSS} %-5p [%c{3.}] (%t) %s%e%n
# - JSON (producción):
#   quarkus.log.console.json=true
#
# Personalización:
# - %d{ISO8601} → 2025-10-12T14:30:45.123-05:00
# - %c{1.} → Solo última parte: [ClienteResource]
# - %C → Clase completa: [pe.banco.prestamos.resource.ClienteResource]
# - %M → Método: [crear]
# - %L → Línea: [45]
quarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n

# Nivel de log global
# Niveles (de menos a más detalle):
# ERROR → Solo errores críticos
# WARN  → Warnings + errores
# INFO  → Información general + warnings + errores ✅
# DEBUG → Debug detallado + todo lo anterior
# TRACE → Traza completa (muy verboso)
#
# INFO es ideal para desarrollo:
# - Muestra eventos importantes
# - No es excesivamente verboso
# - Incluye errores y warnings
#
# Ejemplos de logs por nivel:
# ERROR: Error fatal, aplicación puede fallar
# WARN:  Algo sospechoso pero no crítico
# INFO:  Servidor iniciado, operación completada
# DEBUG: Variables internas, flujo detallado
# TRACE: Cada paso, entrada/salida de métodos
#
# Producción típica:
# quarkus.log.level=WARN
# → Solo warnings y errores
quarkus.log.level=INFO

# Nivel de log para paquete específico
# Categoría: "pe.banco.prestamos" → nuestro código
# Nivel: DEBUG → muy detallado
#
# Sobrescribe el nivel global (INFO) solo para este paquete.
#
# Resultado:
# - pe.banco.prestamos.*: DEBUG
# - io.quarkus.*: INFO (global)
# - org.hibernate.*: INFO (global)
#
# Útil para:
# ✅ Debugear solo tu código (no frameworks)
# ✅ Ver flujo detallado de la aplicación
# ✅ Logs de variables, decisiones, flujos
#
# Agregar logs en código:
# import org.jboss.logging.Logger;
#
# public class ClienteResource {
#     private static final Logger LOG = Logger.getLogger(ClienteResource.class);
#     
#     @POST
#     public Response crear(Cliente cliente) {
#         LOG.debug("Creando cliente: " + cliente.nombre);  // ← Se muestra
#         LOG.info("Cliente creado exitosamente");         // ← Se muestra
#         ...
#     }
# }
#
# Múltiples categorías:
# quarkus.log.category."pe.banco.prestamos".level=DEBUG
# quarkus.log.category."org.hibernate.SQL".level=DEBUG
# quarkus.log.category."io.quarkus.security".level=TRACE
quarkus.log.category."pe.banco.prestamos".level=DEBUG

# ═══════════════════════════════════════════════════════════════
# CONFIGURACIONES ADICIONALES COMUNES (Comentadas)
# ═══════════════════════════════════════════════════════════════

# CORS (Cross-Origin Resource Sharing)
# Permitir requests desde otros dominios (frontend en otro puerto)
# quarkus.http.cors=true
# quarkus.http.cors.origins=http://localhost:3000,http://localhost:4200
# quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS
# quarkus.http.cors.headers=accept,authorization,content-type

# Tamaño máximo de request body
# quarkus.http.body.handle-file-uploads=true
# quarkus.http.limits.max-body-size=10M

# Pool de conexiones (Agroal)
# quarkus.datasource.jdbc.min-size=5
# quarkus.datasource.jdbc.max-size=20
# quarkus.datasource.jdbc.acquisition-timeout=10

# Health Checks
# quarkus.smallrye-health.root-path=/health
# quarkus.smallrye-health.liveness-path=/live
# quarkus.smallrye-health.readiness-path=/ready

# Métricas (Micrometer/Prometheus)
# quarkus.micrometer.enabled=true
# quarkus.micrometer.export.prometheus.enabled=true

# OpenAPI/Swagger
# quarkus.swagger-ui.always-include=true
# quarkus.swagger-ui.path=/swagger

# Flyway (Migraciones de BD)
# quarkus.flyway.migrate-at-start=true
# quarkus.flyway.baseline-on-migrate=true
# quarkus.flyway.locations=classpath:db/migration

# Seguridad JWT
# quarkus.smallrye-jwt.enabled=true
# mp.jwt.verify.publickey.location=META-INF/resources/publicKey.pem

# ═══════════════════════════════════════════════════════════════
# PERFILES POR AMBIENTE (Ejemplos)
# ═══════════════════════════════════════════════════════════════

# DESARROLLO (activo con ./mvnw quarkus:dev)
# %dev.quarkus.hibernate-orm.log.sql=true
# %dev.quarkus.log.level=DEBUG

# TESTS (activo con ./mvnw test)
# %test.quarkus.datasource.db-kind=h2
# %test.quarkus.datasource.jdbc.url=jdbc:h2:mem:testdb
# %test.quarkus.hibernate-orm.database.generation=drop-and-create

# PRODUCCIÓN (activo con java -jar)
# %prod.quarkus.http.port=80
# %prod.quarkus.datasource.username=${DB_USERNAME}
# %prod.quarkus.datasource.password=${DB_PASSWORD}
# %prod.quarkus.hibernate-orm.database.generation=none
# %prod.quarkus.hibernate-orm.log.sql=false
# %prod.quarkus.log.level=WARN

# ═══════════════════════════════════════════════════════════════
# TROUBLESHOOTING COMÚN
# ═══════════════════════════════════════════════════════════════
#
# ERROR: "FATAL: role "rodrigosilva" does not exist"
# SOLUCIÓN:
# - Crear usuario en PostgreSQL:
#   createuser -s rodrigosilva
# - O cambiar a usuario existente:
#   quarkus.datasource.username=postgres
#
# ERROR: "database "postgres" does not exist"
# SOLUCIÓN:
# - Crear base de datos:
#   createdb postgres
# - O usar BD existente:
#   quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/otra_bd
#
# ERROR: "Port 8080 already in use"
# SOLUCIÓN:
# - Cambiar puerto: quarkus.http.port=8081
# - Matar proceso: lsof -ti:8080 | xargs kill -9
#
# ERROR: "No suitable driver found for jdbc:postgresql"
# SOLUCIÓN:
# - Verificar dependencia en pom.xml:
#   <dependency>
#     <groupId>io.quarkus</groupId>
#     <artifactId>quarkus-jdbc-postgresql</artifactId>
#   </dependency>
#
# ═══════════════════════════════════════════════════════════════