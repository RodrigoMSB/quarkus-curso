# ============================================================================
# CONFIGURACIÓN DE QUARKUS - CLIENTES CON SQL SERVER
# ============================================================================
# Archivo de configuración principal para la aplicación de clientes bancarios
# con datos sensibles que requieren cifrado (Capítulo 4.2).
#
# NOTA IMPORTANTE: Este archivo contiene configuración para DESARROLLO LOCAL.
# En PRODUCCIÓN usar perfiles (%prod) y variables de entorno para credenciales.
#
# ⚠️ ADVERTENCIA: Las credenciales visibles aquí son SOLO para desarrollo local.
# NUNCA commitear credenciales de producción en Git.
# ============================================================================

# ----------------------------------------------------------------------------
# DATASOURCE - SQL SERVER (JDBC Tradicional)
# ----------------------------------------------------------------------------
# Configuración del datasource para SQL Server usando el driver JDBC clásico
# (bloqueante, no reactivo). Ideal para operaciones CRUD tradicionales.

# Tipo de base de datos
# Valores posibles: mssql (SQL Server), postgresql, mysql, mariadb, oracle, h2, etc.
quarkus.datasource.db-kind=mssql

# Credenciales de acceso a SQL Server
# Usuario administrador (sa = System Administrator)
# ⚠️ DESARROLLO: OK usar 'sa' localmente para pruebas
# ⚠️ PRODUCCIÓN: Crear usuario específico con permisos limitados (least privilege)
quarkus.datasource.username=sa

# Contraseña del usuario
# ⚠️ SEGURIDAD CRÍTICA:
# - Esta contraseña es para SQL Server en Docker/desarrollo local
# - NUNCA usar contraseñas débiles en producción
# - NUNCA commitear contraseñas reales en Git
# - En producción usar: quarkus.datasource.password=${DB_PASSWORD}
quarkus.datasource.password=Pass123!Admin

# URL de conexión JDBC a SQL Server
# Formato: jdbc:sqlserver://host:puerto;databaseName=nombre;opciones
#
# Componentes:
# - localhost:1433 → Servidor SQL Server local en puerto estándar
# - databaseName=BancoDB → Nombre de la base de datos
# - encrypt=false → NO cifrar conexión (solo para desarrollo local)
# - trustServerCertificate=true → Confiar en certificado auto-firmado
#
# ⚠️ PRODUCCIÓN - Configuración segura requerida:
# jdbc:sqlserver://servidor.azure.com:1433;
#   databaseName=BancoDB;
#   encrypt=true;                    ← OBLIGATORIO cifrar conexión
#   trustServerCertificate=false;    ← Validar certificado real
#   loginTimeout=30;
#   applicationName=ClientesApp
quarkus.datasource.jdbc.url=jdbc:sqlserver://localhost:1433;databaseName=BancoDB;encrypt=false;trustServerCertificate=true

# ----------------------------------------------------------------------------
# HIBERNATE ORM - GESTIÓN DEL ESQUEMA DE BASE DE DATOS
# ----------------------------------------------------------------------------

# Estrategia de generación del esquema
# Valores posibles:
# - none: No hace nada (esquema debe existir previamente)
# - create: Crea el esquema al inicio, conserva datos si existen
# - drop-and-create: BORRA TODO y crea desde cero en cada inicio
# - update: Actualiza el esquema preservando datos (riesgoso en producción)
# - validate: Solo valida que el esquema coincida con las entidades
#
# ⚠️ DESARROLLO: drop-and-create es útil para resetear BD en cada cambio
#    - Ventaja: BD siempre limpia y consistente con el código
#    - Desventaja: Se pierden todos los datos de prueba
#
# ⚠️ PRODUCCIÓN: USAR "none" o "validate" OBLIGATORIAMENTE
#    - Usar herramientas de migración: Flyway o Liquibase
#    - Controlar cambios de esquema con scripts versionados
#    - NUNCA usar drop-and-create (pérdida catastrófica de datos)
quarkus.hibernate-orm.database.generation=drop-and-create

# Logging de sentencias SQL
# true: Imprime todas las queries SQL en la consola
# false: No imprime SQL (recomendado para producción)
#
# Útil para:
# - Debugging: Ver qué queries genera Hibernate
# - Optimización: Identificar queries N+1 o ineficientes
# - Aprendizaje: Entender cómo Hibernate traduce HQL/JPQL a SQL
# - Auditoría de desarrollo: Ver qué datos se están modificando
#
# ⚠️ PRODUCCIÓN: Establecer en false para:
#    - Reducir volumen de logs (ahorro de almacenamiento)
#    - Mejorar performance (menos I/O)
#    - Evitar exponer estructura de BD en logs
#    - Prevenir fuga de datos sensibles en queries con parámetros
quarkus.hibernate-orm.log.sql=true

# Script SQL de inicialización (COMENTADO - No usado en este proyecto)
# Archivo: src/main/resources/import.sql
#
# Si se descomenta, Hibernate ejecuta este script DESPUÉS de crear el esquema
# Útil para:
# - Insertar datos de prueba automáticamente
# - Poblar catálogos o tablas de configuración
# - Datos de seed para desarrollo
#
# Ejemplo de import.sql:
# INSERT INTO Cliente (id, nombre, numero_tarjeta, email, telefono)
# VALUES (1, 'Juan Pérez', '4532-1234-5678-9012', 'juan@banco.com', '+56912345678');
#
# ⚠️ Solo se ejecuta cuando database.generation != none
# quarkus.hibernate-orm.sql-load-script=import.sql

# ----------------------------------------------------------------------------
# SERVIDOR HTTP
# ----------------------------------------------------------------------------

# Puerto en el que escucha el servidor HTTP
# Default: 8080
# Cambiar si:
# - Hay conflicto con otra aplicación en el mismo puerto
# - Se requiere puerto específico por políticas de red
# - Se ejecutan múltiples instancias de Quarkus simultáneamente
quarkus.http.port=8080

# ----------------------------------------------------------------------------
# CONFIGURACIONES ADICIONALES ÚTILES (COMENTADAS)
# ----------------------------------------------------------------------------

# Pool de conexiones - Configuración avanzada
# Máximo de conexiones en el pool (default: 20)
# quarkus.datasource.jdbc.max-size=20

# Mínimo de conexiones activas en el pool (default: 0)
# quarkus.datasource.jdbc.min-size=5

# Timeout de conexión en segundos (default: 30)
# quarkus.datasource.jdbc.acquisition-timeout=30

# Tiempo máximo de vida de una conexión en minutos
# quarkus.datasource.jdbc.max-lifetime=30

# Validación de conexiones antes de usar (detecta conexiones rotas)
# quarkus.datasource.jdbc.validation-query-sql=SELECT 1

# Logs de Quarkus
# quarkus.log.level=INFO
# quarkus.log.category."org.hibernate".level=DEBUG
# quarkus.log.category."org.hibernate.SQL".level=DEBUG
# quarkus.log.category."org.hibernate.type.descriptor.sql.BasicBinder".level=TRACE

# CORS (para desarrollo con frontend en otro puerto)
# quarkus.http.cors=true
# quarkus.http.cors.origins=http://localhost:3000
# quarkus.http.cors.methods=GET,POST,PUT,DELETE
# quarkus.http.cors.headers=Content-Type,Authorization

# Health checks y métricas
# quarkus.datasource.health.enabled=true
# quarkus.smallrye-health.ui.enable=true

# ----------------------------------------------------------------------------
# PERFILES DE ENTORNO
# ----------------------------------------------------------------------------
# Quarkus soporta perfiles para diferentes entornos usando el prefijo %perfil
#
# DESARROLLO (por defecto - este archivo):
# - SQL Server local en Docker
# - drop-and-create para BD limpia
# - Logs SQL habilitados
# - Credenciales visibles para facilitar desarrollo
#
# PRUEBAS (%test):
# %test.quarkus.datasource.jdbc.url=jdbc:sqlserver://localhost:1433;databaseName=BancoDB_Test;...
# %test.quarkus.hibernate-orm.database.generation=drop-and-create
# %test.quarkus.datasource.username=test_user
# %test.quarkus.datasource.password=test_pass
#
# PRODUCCIÓN (%prod):
# %prod.quarkus.datasource.jdbc.url=${DATABASE_URL}
# %prod.quarkus.datasource.username=${DB_USER}
# %prod.quarkus.datasource.password=${DB_PASSWORD}
# %prod.quarkus.hibernate-orm.database.generation=none
# %prod.quarkus.hibernate-orm.log.sql=false
# %prod.quarkus.datasource.jdbc.max-size=50
#
# Activar perfil específico:
# ./mvnw quarkus:dev -Dquarkus.profile=prod
#
# Variables de entorno en producción:
# export DATABASE_URL="jdbc:sqlserver://prod.database.com:1433;databaseName=BancoDB;encrypt=true"
# export DB_USER="app_user"
# export DB_PASSWORD="SecurePassword123!"
# ----------------------------------------------------------------------------

# ============================================================================
# CONTEXTO DEL PROYECTO: CIFRADO DE DATOS SENSIBLES
# ============================================================================
# Este proyecto (Capítulo 4.2) implementa cifrado de datos sensibles con:
# - Google Tink (AES-256-GCM) para cifrar numeroTarjeta y email
# - Cifrado a nivel de aplicación (no Always Encrypted)
# - Compliance con PCI-DSS y GDPR
#
# Base de datos: BancoDB contiene tabla Cliente con:
# - nombre (texto plano)
# - numero_tarjeta (TEXT cifrado en Base64)
# - email (TEXT cifrado en Base64)
# - telefono (texto plano)
#
# ⚠️ IMPORTANTE: 
# - Los datos se cifran en la capa de aplicación ANTES de persistir
# - SQL Server almacena texto cifrado ilegible
# - La clave de cifrado NO está en este archivo (ver CryptoService)
# - En producción, la clave debe estar en KMS (Azure Key Vault, AWS KMS, etc.)
# ============================================================================

# ============================================================================
# MEJORES PRÁCTICAS PARA SQL SERVER EN PRODUCCIÓN
# ============================================================================
# 1. SEGURIDAD:
#    - Usar Always Encrypted para capa adicional de seguridad
#    - Habilitar TDE (Transparent Data Encryption) en SQL Server
#    - Conectar solo con encrypt=true y certificados válidos
#    - Usar Azure Active Directory authentication si está en Azure
#    - NUNCA usar cuenta 'sa' en producción
#
# 2. CREDENCIALES:
#    - Almacenar en Azure Key Vault, AWS Secrets Manager, o HashiCorp Vault
#    - Rotar contraseñas periódicamente (cada 90 días)
#    - Usar managed identities en la nube cuando sea posible
#
# 3. MONITOREO:
#    - Habilitar query store para análisis de performance
#    - Configurar alertas de SQL Server para conexiones fallidas
#    - Monitorear uso de pool de conexiones
#
# 4. PERFORMANCE:
#    - Ajustar tamaño de pool según carga (jdbc.max-size)
#    - Usar índices apropiados en columnas de búsqueda frecuente
#    - Considerar read replicas para operaciones de lectura intensiva
#
# 5. BACKUP:
#    - Configurar backups automáticos diarios
#    - Probar restauración periódicamente
#    - Backup de claves de cifrado en ubicación separada
# ============================================================================

# ============================================================================
# TROUBLESHOOTING COMÚN
# ============================================================================
# 
# Error: "Login failed for user 'sa'"
# Solución: Verificar que SQL Server acepta autenticación SQL
#           En Docker: -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=Pass123!Admin"
#
# Error: "The TCP/IP connection to the host has failed"
# Solución: Verificar que SQL Server está corriendo y puerto 1433 abierto
#           docker ps | grep sqlserver
#           netstat -an | grep 1433
#
# Error: "SSL Security error"
# Solución: Agregar ;encrypt=false;trustServerCertificate=true a la URL
#           O instalar certificado válido en SQL Server
#
# Error: "Database 'BancoDB' does not exist"
# Solución: Crear la BD manualmente o usar database.generation=create
#           CREATE DATABASE BancoDB;
#
# Performance lento:
# Solución: Verificar índices en columnas de búsqueda frecuente
#           Aumentar jdbc.max-size si hay muchas conexiones concurrentes
#           Revisar queries con log.sql=true
# ============================================================================
