# ğŸ“Š Comparativa: ProgramaciÃ³n Reactiva vs ClÃ¡sica en Quarkus

> **AnÃ¡lisis de Performance**: Tests de concurrencia comparando el enfoque reactivo (Mutiny) contra el enfoque clÃ¡sico (blocking) en operaciones CRUD con base de datos.

---

## ğŸ“‹ Resumen Ejecutivo

Este documento presenta un anÃ¡lisis comparativo detallado entre dos enfoques de programaciÃ³n en Quarkus:

- **Enfoque Reactivo (Mutiny)**: ProgramaciÃ³n no bloqueante con tipos reactivos `Uni<T>` y `Multi<T>`
- **Enfoque ClÃ¡sico (Blocking)**: ProgramaciÃ³n tradicional con operaciones sÃ­ncronas

Los tests se ejecutaron con **k6** (Grafana Labs - herramienta profesional de benchmarking) bajo tres niveles de carga:
- **1,000 requests** con 50 workers (carga ligera)
- **5,000 requests** con 100 workers (carga media)
- **10,000 requests** con 200 workers (carga alta)

---

## ğŸ“Š Tabla Comparativa Completa

### Test 1K Requests (Carga Ligera)

| MÃ©trica | Reactivo âš¡ | ClÃ¡sico ğŸ“¦ | ObservaciÃ³n |
|---------|-------------|------------|-------------|
| **Throughput** | 2618 req/s | 2117 req/s | Reactivo mÃ¡s rÃ¡pido |
| **Latencia promedio** | 0.0186 | 0.0230 | Ambos en rango aceptable |
| **p50 (mediana)** | 0.0097 | 0.0033 | Experiencia tÃ­pica |
| **p95** | 0.0520 | 0.1283 | Reactivo mÃ¡s consistente |
| **p99** | 0.0757 | 0.1384 | Peor 1% de usuarios |

---

### Test 5K Requests (Carga Media) - ğŸ¯ SWEET SPOT

| MÃ©trica | Reactivo âš¡ | ClÃ¡sico ğŸ“¦ | ObservaciÃ³n |
|---------|-------------|------------|-------------|
| **Throughput** | 8107 req/s | 1951 req/s | **DIFERENCIA BRUTAL** ğŸ”¥ |
| **Latencia promedio** | 0.0121 | 0.0510 | Reactivo significativamente mejor |
| **p50 (mediana)** | 0.0117 | 0.0254 | Experiencia del usuario promedio |
| **p95** | 0.0170 | 0.1876 | **Reactivo mucho mejor** ğŸš€ |
| **p99** | 0.0202 | 0.2710 | ClÃ¡sico con latencias altas |

> **ğŸ’¡ Este es el SWEET SPOT**: El punto donde la programaciÃ³n reactiva muestra su mÃ¡xima ventaja. El enfoque clÃ¡sico colapsa por saturaciÃ³n del pool de threads.

---

### Test 10K Requests (Carga Alta)

| MÃ©trica | Reactivo âš¡ | ClÃ¡sico ğŸ“¦ | ObservaciÃ³n |
|---------|-------------|------------|-------------|
| **Throughput** | 7838 req/s | 1824 req/s | Reactivo mantiene alto rendimiento |
| **Latencia promedio** | 0.0250 | 0.1090 | Diferencia significativa |
| **p50 (mediana)** | 0.0244 | 0.0829 | Usuario promedio sufre en clÃ¡sico |
| **p95** | 0.0311 | 0.3011 | Reactivo mantiene consistencia |
| **p99** | 0.0454 | 0.3987 | ClÃ¡sico con timeouts probables |

---

## ğŸ“ˆ GrÃ¡fico de Throughput (Requests/segundo)

```
Throughput Comparativo

10K â”¤
    â”‚  R: 7838 req/s
8K  â”¤  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ Reactivo
    â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
6K  â”¤  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† SWEET SPOT (5K)
4K  â”¤  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â”‚  â–ˆâ–ˆâ–ˆâ–ˆ
2K  â”¤  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ  C: 1824 req/s
    â”‚  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ ClÃ¡sico
0   â””â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      1K    5K   10K

Datos reales:
â”œâ”€ 1K:  Reactivo 2618 vs ClÃ¡sico 2117 req/s
â”œâ”€ 5K:  Reactivo 8107 vs ClÃ¡sico 1951 req/s
â””â”€ 10K: Reactivo 7838 vs ClÃ¡sico 1824 req/s
```

**OBSERVACIÃ“N CLAVE:**
- En **1K**: Ambos comparables, reactivo ligeramente superior
- En **5K**: Reactivo EXPLOTA ğŸš€ (clÃ¡sico colapsa)  
- En **10K**: Reactivo mantiene rendimiento, clÃ¡sico saturado

---

## ğŸ“‰ GrÃ¡fico de Latencia p95 (milisegundos)

```
Latencia Percentil 95

350ms â”¤
      â”‚                      C: 301.1000ms
300ms â”¤                      â–ˆâ–ˆâ–ˆâ–ˆ ClÃ¡sico (10K)
      â”‚
250ms â”¤
      â”‚
200ms â”¤                  C: 187.6000ms
      â”‚              â–ˆâ–ˆâ–ˆâ–ˆ ClÃ¡sico (5K)
150ms â”¤              â–ˆâ–ˆ
      â”‚
100ms â”¤          C: 128.3000ms
      â”‚      â–ˆâ–ˆâ–ˆâ–ˆ ClÃ¡sico (1K)
50ms  â”¤  â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ Reactivo (todas las cargas)
      â”‚  R: 52.0000ms, 17.0000ms, 31.1000ms
0ms   â””â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        1K   5K  10K

INTERPRETACIÃ“N:
- Reactivo mantiene latencias p95 bajas y consistentes
- ClÃ¡sico degrada significativamente bajo carga media/alta
- En 5K (sweet spot): diferencia mÃ¡s dramÃ¡tica
```

---

## ğŸ¯ Â¿QuÃ© es el SWEET SPOT?

El **Sweet Spot** es el punto Ã³ptimo donde una tecnologÃ­a muestra su mÃ¡xima ventaja comparativa.

### AnalogÃ­a del Motor Turbo

```
Motor tradicional (enfoque clÃ¡sico):
â”œâ”€ Baja velocidad: Funciona bien
â”œâ”€ Media velocidad: Empieza a esforzarse  
â””â”€ Alta velocidad: Se sobrecalienta

Motor turbo (enfoque reactivo):
â”œâ”€ Baja velocidad: Overhead del turbo, ventaja pequeÃ±a
â”œâ”€ Media velocidad: TURBO ACTIVO ğŸ”¥ (sweet spot)
â””â”€ Alta velocidad: Ventaja grande pero limitada por otros factores
```

### En Nuestros Tests

| Carga | Â¿Por quÃ© sucede? |
|-------|------------------|
| **1K (Baja)** | Poca concurrencia. Ambos tienen threads disponibles. El overhead reactivo es visible. Ventaja moderada. |
| **5K (Media)** ğŸ¯ | **SWEET SPOT**: Suficiente concurrencia para que Mutiny brille. El clÃ¡sico satura threads. BD aÃºn responde rÃ¡pido. **MÃXIMA DIFERENCIA**. |
| **10K (Alta)** | ClÃ¡sico completamente saturado. BD se vuelve cuello de botella para ambos. Reactivo sigue bien pero BD limita el throughput mÃ¡ximo. |

---

## ğŸ“– ExplicaciÃ³n de MÃ©tricas

### ğŸ”¹ Throughput (Requests/sec)

**Â¿QuÃ© es?**  
Cantidad de peticiones que el servidor puede procesar por segundo.

**Â¿Por quÃ© importa?**  
Mayor throughput = mÃ¡s usuarios simultÃ¡neos soportados = mayor capacidad de negocio.

**Ejemplo prÃ¡ctico con nuestros nÃºmeros:**
```
API de e-commerce en Black Friday (test 5K):
- Reactivo: 8107 req/s â†’ Soporta 8107 usuarios/segundo
- ClÃ¡sico: 1951 req/s â†’ Soporta 1951 usuarios/segundo

Diferencia: 6156 usuarios mÃ¡s por segundo
```

---

### ğŸ”¹ Latencia Promedio (Average)

**Â¿QuÃ© es?**  
Tiempo promedio que tarda el servidor en responder una peticiÃ³n.

**Â¿Por quÃ© importa?**  
Afecta directamente la experiencia del usuario y las conversiones.

**Regla de oro:**
- **< 100ms**: Excelente (usuario no percibe delay)
- **100-300ms**: Aceptable
- **300-1000ms**: Lento (usuario nota el delay)
- **> 1000ms**: Inaceptable (usuarios abandonan)

**En nuestro test de 5K:**
```
Reactivo: 12.1000ms  âœ… Excelente
ClÃ¡sico: 51.0000ms   âš ï¸  Perceptible
```

---

### ğŸ”¹ Percentiles (p50, p95, p99)

**Â¿QuÃ© son?**  
Indican el tiempo mÃ¡ximo que tardÃ³ un porcentaje de peticiones.

**ExplicaciÃ³n simple:**

| Percentil | Significado | Importancia |
|-----------|-------------|-------------|
| **p50** | 50% de peticiones mÃ¡s rÃ¡pidas que este tiempo | Experiencia del usuario "promedio" |
| **p95** | 95% de peticiones mÃ¡s rÃ¡pidas que este tiempo | SLA tÃ­pico de producciÃ³n |
| **p99** | 99% de peticiones mÃ¡s rÃ¡pidas que este tiempo | Experiencia del peor 1% |

**Ejemplo con 5000 usuarios (test 5K):**

```
Reactivo - p95 = 0.0170 significa:
â”œâ”€ 4,750 usuarios (95%) tuvieron respuesta en â‰¤17.0000ms  âœ…
â””â”€ 250 usuarios (5%) tuvieron respuesta en >17.0000ms

ClÃ¡sico - p95 = 0.1876 significa:
â”œâ”€ 4,750 usuarios (95%) tuvieron respuesta en â‰¤187.6000ms âš ï¸
â””â”€ 250 usuarios (5%) tuvieron respuesta en >187.6000ms  âŒ
```

**Â¿Por quÃ© p95 importa mÃ¡s que el promedio?**

Porque define la experiencia del usuario bajo carga:

```
Escenario Reactivo (5K):
â”œâ”€ Promedio: 12.1000ms
â””â”€ p95: 17.0000ms
   â†’ Experiencia CONSISTENTE âœ…

Escenario ClÃ¡sico (5K):
â”œâ”€ Promedio: 51.0000ms
â””â”€ p95: 187.6000ms
   â†’ Experiencia INCONSISTENTE âš ï¸
   â†’ El 5% de usuarios sufre mucho mÃ¡s
```

---

## ğŸ“ InterpretaciÃ³n para Decisiones de Arquitectura

### âœ… Usar Enfoque REACTIVO cuando:

1. **Alta concurrencia** (>1,000 requests/segundo)
   - Ejemplo: API pÃºblica de pagos, redes sociales

2. **Operaciones I/O intensivas**
   - MÃºltiples consultas a BD por request
   - Llamadas a APIs externas
   - Procesamiento de archivos

3. **SLAs estrictos**
   - Necesitas garantizar p95 < 100ms
   - Latencias predecibles bajo carga

4. **Escalabilidad horizontal**
   - Cloud (AWS, GCP, Azure)
   - Kubernetes
   - Serverless (Lambda, Cloud Functions)

5. **Recursos limitados**
   - Menos memoria (threads pesan)
   - Menos cores disponibles

**Caso de uso real:**
```
Pasarela de pagos que procesa 10,000 transacciones/segundo
- Enfoque clÃ¡sico: Necesita 100+ threads (alto consumo RAM)
- Enfoque reactivo: Funciona con 10-20 threads

Ahorro: 80% menos memoria + mejor throughput
```

---

### âœ… Usar Enfoque CLÃSICO cuando:

1. **CRUD simple** (<500 requests/segundo)
   - Backoffice interno
   - Aplicaciones administrativas

2. **Equipo sin experiencia reactiva**
   - Curva de aprendizaje empinada
   - Debugging mÃ¡s complejo

3. **CÃ³digo legado** que no se puede migrar
   - LibrerÃ­as bloqueantes
   - Integraciones legacy

4. **Desarrollo rÃ¡pido** (MVPs, prototipos)
   - Menos cÃ³digo
   - MÃ¡s directo

5. **Debugging frecuente**
   - Stack traces lineales
   - MÃ¡s fÃ¡cil troubleshooting

**Caso de uso real:**
```
Panel administrativo para 50 usuarios internos
- MÃ¡ximo 10 peticiones simultÃ¡neas
- No justifica complejidad reactiva
- Enfoque clÃ¡sico: SUFICIENTE y mÃ¡s simple
```

---

## ğŸ”¬ AnÃ¡lisis TÃ©cnico del Colapso ClÃ¡sico

### Â¿Por quÃ© el enfoque clÃ¡sico colapsa en 5K?

#### Modelo Thread-Per-Request (ClÃ¡sico)

```
Request 1 â†’ Thread 1 [BLOQUEADO esperando BD]
Request 2 â†’ Thread 2 [BLOQUEADO esperando BD]
Request 3 â†’ Thread 3 [BLOQUEADO esperando BD]
...
Request 100 â†’ Thread 100 [BLOQUEADO esperando BD]
Request 101 â†’ â³ ESPERA (no hay threads disponibles)
Request 102 â†’ â³ ESPERA
...
```

**Problema:**
- Pool tÃ­pico: 100-200 threads
- Con 5K requests simultÃ¡neos â†’ threads saturados
- Nuevas peticiones en COLA esperando thread disponible
- Latencias se disparan (p95 = 0.1876)

#### Modelo Reactivo (Mutiny)

```
Request 1 â†’ Thread 1 [envÃ­a query a BD] â†’ libera thread
Request 2 â†’ Thread 1 [envÃ­a query a BD] â†’ libera thread
Request 3 â†’ Thread 1 [envÃ­a query a BD] â†’ libera thread
...
Request 5000 â†’ Thread 10 [envÃ­a query a BD] â†’ libera thread

Cuando BD responde â†’ callback procesa resultado
```

**Ventaja:**
- Pool pequeÃ±o: 10-20 threads suficientes
- Threads NO se bloquean
- Pueden procesar miles de peticiones concurrentes
- Latencias consistentes (p95 = 0.0170)

---

## ğŸ’¡ ConclusiÃ³n

### Resumen de Resultados Obtenidos

| Aspecto | Reactivo | ClÃ¡sico | Mejor |
|---------|----------|---------|-------|
| **Throughput 5K** | 8107 req/s | 1951 req/s | Reactivo |
| **Latencia p95 5K** | 0.0170 | 0.1876 | Reactivo |
| **Consistencia** | Alta | Degrada bajo carga | Reactivo |
| **Complejidad cÃ³digo** | Alta | Baja | ClÃ¡sico |
| **Debugging** | Complejo | Simple | ClÃ¡sico |

### La DecisiÃ³n Correcta

**No existe una respuesta Ãºnica.** La elecciÃ³n depende de:

1. **VolumetrÃ­a esperada** (usuarios concurrentes)
2. **SLAs requeridos** (p95, p99 targets)
3. **Experiencia del equipo**
4. **Restricciones de infraestructura**
5. **Tiempo de desarrollo disponible**

### Regla PrÃ¡ctica

```
if (concurrencia > 1000 req/s || SLA p95 < 100ms) {
    usar_reactivo();
} else if (equipo_sin_experiencia && volumetrÃ­a_baja) {
    usar_clÃ¡sico();
} else {
    evaluar_caso_por_caso();
}
```

---

## ğŸ“š Recursos Adicionales

### DocumentaciÃ³n Oficial
- [Quarkus Reactive Architecture](https://quarkus.io/guides/quarkus-reactive-architecture)
- [Mutiny Documentation](https://smallrye.io/smallrye-mutiny/)
- [Hibernate Reactive](https://hibernate.org/reactive/)

### Herramientas de Benchmarking
- [k6](https://k6.io/) - HTTP load generator usado en estos tests (Grafana Labs)
- [wrk](https://github.com/wg/wrk) - Alternativa potente
- [Apache JMeter](https://jmeter.apache.org/) - Suite completa de testing

### Lecturas Recomendadas
- [Reactive Manifesto](https://www.reactivemanifesto.org/)
- [Project Reactor vs Mutiny](https://quarkus.io/blog/mutiny-vs-reactive/)

---

**Generado automÃ¡ticamente por:** `generar-comparativa.sh`  
**Fecha:** 2025-12-02 18:25:24  
**Archivos analizados:**
- Reactivo: `resultados-reactivo-20251202_182407.txt`
- ClÃ¡sico: `resultados-clasico-20251202_182438.txt`
