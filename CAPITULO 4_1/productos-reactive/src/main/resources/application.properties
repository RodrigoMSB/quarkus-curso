# ============================================================================
# CONFIGURACIÓN DE QUARKUS - APLICACIÓN REACTIVA CON POSTGRESQL
# ============================================================================
# Archivo de configuración principal para la aplicación de productos reactivos.
# Este archivo define propiedades de base de datos, Hibernate y servidor HTTP.
#
# NOTA IMPORTANTE: Este archivo contiene configuración para DESARROLLO.
# En PRODUCCIÓN usar perfiles (%prod) y variables de entorno para credenciales.
# ============================================================================

# ----------------------------------------------------------------------------
# DATASOURCE REACTIVO - POSTGRESQL
# ----------------------------------------------------------------------------
# Configuración del datasource para operaciones reactivas no bloqueantes.
# Usa el driver PostgreSQL reactivo (Vert.x) en lugar del driver JDBC tradicional.

# Tipo de base de datos
# Valores posibles: postgresql, mysql, mariadb, mssql, oracle, h2, etc.
quarkus.datasource.db-kind=postgresql

# Credenciales de acceso a PostgreSQL
# Usuario de la base de datos
quarkus.datasource.username=rodrigosilva

# Contraseña (vacía en este caso - típico en entornos de desarrollo local)
# ⚠️ PRODUCCIÓN: NUNCA dejar vacío. Usar variables de entorno:
#    quarkus.datasource.password=${DB_PASSWORD}
quarkus.datasource.password=

# URL de conexión reactiva (NO es JDBC)
# Formato: postgresql://host:puerto/nombre_base_datos
# - localhost: servidor PostgreSQL local
# - 5432: puerto por defecto de PostgreSQL
# - postgres: nombre de la base de datos
quarkus.datasource.reactive.url=postgresql://localhost:5432/postgres

# ----------------------------------------------------------------------------
# DESACTIVAR JDBC
# ----------------------------------------------------------------------------
# CRÍTICO: Como usamos el driver reactivo (Vert.x), desactivamos JDBC explícitamente
# para evitar conflictos y reducir el uso de recursos.
#
# Si esto se establece en true, Quarkus intentará crear un pool de conexiones JDBC
# que NO es necesario en una aplicación 100% reactiva.
quarkus.datasource.jdbc=false

# ----------------------------------------------------------------------------
# HIBERNATE ORM - GESTIÓN DEL ESQUEMA DE BASE DE DATOS
# ----------------------------------------------------------------------------

# Estrategia de generación del esquema de base de datos
# Valores posibles:
# - none: No hace nada (BD debe existir previamente)
# - create: Crea el esquema al inicio (no borra datos existentes)
# - drop-and-create: BORRA todo y crea desde cero en cada inicio
# - update: Actualiza el esquema preservando datos (no recomendado en producción)
# - validate: Solo valida que el esquema coincida con las entidades
#
# ⚠️ DESARROLLO: drop-and-create es útil para resetear la BD en cada cambio
# ⚠️ PRODUCCIÓN: Usar "none" o "validate" + herramientas de migración (Flyway/Liquibase)
quarkus.hibernate-orm.database.generation=drop-and-create

# Logging de sentencias SQL
# true: Imprime todas las queries SQL en la consola (útil para debugging)
# false: No imprime SQL (mejor para producción)
#
# Útil para:
# - Entender qué queries genera Hibernate
# - Optimizar consultas lentas
# - Debugging de problemas de persistencia
quarkus.hibernate-orm.log.sql=true

# Script SQL de inicialización
# Archivo con datos de prueba que se ejecuta DESPUÉS de crear el esquema
# Ubicación: src/main/resources/import.sql
#
# Ejemplo de import.sql:
# INSERT INTO Producto (id, nombre, descripcion, precio, stock) 
# VALUES (1, 'Laptop Dell', 'XPS 15', 1299.99, 10);
#
# ⚠️ Solo se ejecuta cuando database.generation != none
quarkus.hibernate-orm.sql-load-script=import.sql

# ----------------------------------------------------------------------------
# SERVIDOR HTTP
# ----------------------------------------------------------------------------

# Puerto en el que escucha el servidor HTTP
# Default: 8080
# Cambiar si hay conflictos con otras aplicaciones en el mismo puerto
quarkus.http.port=8080

# ----------------------------------------------------------------------------
# CONFIGURACIONES ADICIONALES ÚTILES (COMENTADAS)
# ----------------------------------------------------------------------------
# Descomentar según necesidad:

# Timeout de conexión reactiva (milisegundos)
# quarkus.datasource.reactive.connection-timeout=30000

# Tamaño máximo del pool de conexiones reactivas
# Default: Calculado dinámicamente por Vert.x
# quarkus.datasource.reactive.max-size=20

# Tiempo máximo de vida de una conexión (milisegundos)
# quarkus.datasource.reactive.max-lifetime=PT30M

# Modo de desarrollo con live reload
# quarkus.live-reload.instrumentation=true

# CORS (para desarrollo con frontend en otro puerto)
# quarkus.http.cors=true
# quarkus.http.cors.origins=http://localhost:3000

# Logs de Quarkus
# quarkus.log.level=INFO
# quarkus.log.category."io.quarkus".level=DEBUG

# ----------------------------------------------------------------------------
# PERFILES DE ENTORNO
# ----------------------------------------------------------------------------
# Quarkus soporta perfiles para diferentes entornos:
#
# DESARROLLO (por defecto):
# - Configuración actual
#
# PRUEBAS (%test):
# %test.quarkus.datasource.reactive.url=postgresql://localhost:5432/test_db
# %test.quarkus.hibernate-orm.database.generation=drop-and-create
#
# PRODUCCIÓN (%prod):
# %prod.quarkus.datasource.reactive.url=${DATABASE_URL}
# %prod.quarkus.datasource.username=${DB_USER}
# %prod.quarkus.datasource.password=${DB_PASSWORD}
# %prod.quarkus.hibernate-orm.database.generation=none
# %prod.quarkus.hibernate-orm.log.sql=false
#
# Activar perfil:
# ./mvnw quarkus:dev -Dquarkus.profile=prod
# ----------------------------------------------------------------------------

# ============================================================================
# MEJORES PRÁCTICAS PARA PRODUCCIÓN
# ============================================================================
# 1. NUNCA hardcodear credenciales - usar variables de entorno
# 2. database.generation=none y usar Flyway/Liquibase para migraciones
# 3. log.sql=false para no exponer queries en logs de producción
# 4. Configurar SSL para conexión a PostgreSQL en la nube
# 5. Implementar health checks y métricas (Micrometer)
# 6. Usar secrets managers (AWS Secrets Manager, Azure Key Vault, etc.)
# ============================================================================