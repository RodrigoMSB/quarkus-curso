# üìö TEOR√çA - Cap√≠tulo 10: Patrones Avanzados para Microservicios

## Sistema E-Commerce con Patr√≥n SAGA y Redis Cache

---

## üìã Tabla de Contenidos

1. [Introducci√≥n](#1-introducci√≥n)
2. [El Problema de las Transacciones Distribuidas](#2-el-problema-de-las-transacciones-distribuidas)
3. [Patr√≥n SAGA en Profundidad](#3-patr√≥n-saga-en-profundidad)
4. [Redis Cache y Patrones de Cach√©](#4-redis-cache-y-patrones-de-cach√©)
5. [Circuit Breaker y Fault Tolerance](#5-circuit-breaker-y-fault-tolerance)
6. [Consistencia Eventual](#6-consistencia-eventual)
7. [Comparaciones y Trade-offs](#7-comparaciones-y-trade-offs)
8. [Casos de Uso Reales](#8-casos-de-uso-reales)
9. [Mejores Pr√°cticas](#9-mejores-pr√°cticas)
10. [Antipatrones Comunes](#10-antipatrones-comunes)
11. [Referencias y Recursos](#11-referencias-y-recursos)

---

## 1. Introducci√≥n

### üéØ ¬øPor qu√© este cap√≠tulo es crucial?

En arquitecturas de microservicios, dos desaf√≠os fundamentales emergen constantemente:

1. **¬øC√≥mo coordinar operaciones que involucran m√∫ltiples servicios?**
2. **¬øC√≥mo optimizar el rendimiento sin sacrificar la consistencia?**

Este cap√≠tulo aborda ambas preguntas implementando:
- **Patr√≥n SAGA**: Para transacciones distribuidas con compensaciones
- **Redis Cache**: Para optimizaci√≥n de consultas frecuentes

### üé≠ Analog√≠a del Director de Orquesta

Imagina una orquesta sinf√≥nica tocando una pieza compleja:

- **Sin coordinaci√≥n**: Cada m√∫sico toca a su ritmo ‚Üí Caos total
- **Con director (SAGA)**: El director coordina, y si un violinista se equivoca, el director puede indicar "volvamos al comp√°s anterior" (compensaci√≥n)
- **Con memoria (Cache)**: Los m√∫sicos tienen las partituras memorizadas para las piezas que tocan frecuentemente ‚Üí No necesitan mirar constantemente el atril

---

## 2. El Problema de las Transacciones Distribuidas

### 2.1 Transacciones ACID vs BASE

#### ACID (Bases de Datos Monol√≠ticas)

En una aplicaci√≥n monol√≠tica con una sola base de datos, tenemos:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     APLICACI√ìN MONOL√çTICA       ‚îÇ
‚îÇ                                 ‚îÇ
‚îÇ  BEGIN TRANSACTION;             ‚îÇ
‚îÇ    UPDATE accounts              ‚îÇ
‚îÇ      SET balance = balance - 100‚îÇ
‚îÇ      WHERE id = 1;              ‚îÇ
‚îÇ                                 ‚îÇ
‚îÇ    UPDATE accounts              ‚îÇ
‚îÇ      SET balance = balance + 100‚îÇ
‚îÇ      WHERE id = 2;              ‚îÇ
‚îÇ  COMMIT;                        ‚îÇ
‚îÇ                                 ‚îÇ
‚îÇ  ‚úÖ Todo o nada (atomicidad)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   BD    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Garant√≠as ACID:**
- **A**tomicity: Todo o nada
- **C**onsistency: Datos siempre consistentes
- **I**solation: Transacciones aisladas
- **D**urability: Cambios permanentes

#### BASE (Microservicios Distribuidos)

Con microservicios, cada servicio tiene su propia base de datos:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Order Service ‚îÇ       ‚îÇInventory Svc  ‚îÇ       ‚îÇ Payment Svc   ‚îÇ
‚îÇ               ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ               ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ               ‚îÇ
‚îÇ BD Orders     ‚îÇ       ‚îÇ BD Inventory  ‚îÇ       ‚îÇ BD Payments   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚ùå NO podemos hacer una transacci√≥n ACID entre 3 BDs diferentes
```

**Propiedades BASE:**
- **B**asically **A**vailable: Sistema siempre disponible
- **S**oft state: El estado puede cambiar sin input (eventual)
- **E**ventual consistency: Consistencia eventual, no inmediata

### 2.2 El Teorema CAP

**Teorema CAP** (Eric Brewer, 2000): En un sistema distribuido, solo puedes garantizar 2 de 3:

```
         Consistencia (C)
              ‚ñ≤
             ‚ï± ‚ï≤
            ‚ï±   ‚ï≤
           ‚ï±     ‚ï≤
          ‚ï±  ‚ùì   ‚ï≤
         ‚ï±         ‚ï≤
        ‚ï±___________‚ï≤
    Disponibilidad  Tolerancia a
         (A)        Particiones (P)

Microservicios ‚Üí Elegimos AP (Disponibilidad + Particiones)
Perdemos C (Consistencia inmediata) ‚Üí Usamos consistencia eventual
```

**Analog√≠a**: Es como un sistema de mensajer√≠a:
- **CA**: Todos ven el mismo mensaje al mismo tiempo, pero si la red falla, el sistema se cae
- **AP**: El sistema siempre funciona, pero puede haber retraso en que todos vean el mensaje
- **CP**: Todos ven lo mismo o nadie ve nada (no √∫til para alta disponibilidad)

### 2.3 El Problema de 2PC (Two-Phase Commit)

**2PC** es la soluci√≥n "cl√°sica" para transacciones distribuidas:

```mermaid
sequenceDiagram
    participant C as Coordinador
    participant S1 as Servicio 1
    participant S2 as Servicio 2
    participant S3 as Servicio 3
    
    Note over C: FASE 1: PREPARE
    C->>S1: ¬øPuedes hacer commit?
    S1-->>C: S√≠, estoy listo
    C->>S2: ¬øPuedes hacer commit?
    S2-->>C: S√≠, estoy listo
    C->>S3: ¬øPuedes hacer commit?
    Note over S3: ‚ö†Ô∏è TIMEOUT / FALLO
    S3-->>C: No responde
    
    Note over C: FASE 2: ABORT
    C->>S1: ROLLBACK
    C->>S2: ROLLBACK
    
    Note over C,S3: ‚ùå Todos bloqueados esperando
```

**Problemas de 2PC:**
1. **Bloqueo**: Todos esperan al m√°s lento
2. **Punto √∫nico de fallo**: Si el coordinador falla, todos se bloquean
3. **No escalable**: Crece O(n¬≤) con el n√∫mero de servicios
4. **Latencia alta**: Dos viajes de red completos

**Analog√≠a**: Es como un grupo de amigos decidiendo d√≥nde ir a comer:
- **2PC**: "Nadie pide hasta que TODOS hayamos decidido" ‚Üí Si uno est√° indeciso, NADIE come
- **SAGA**: "Vamos pidiendo, y si alguien cambia de opini√≥n, cancelamos su pedido" ‚Üí Progreso constante

---

## 3. Patr√≥n SAGA en Profundidad

### 3.1 ¬øQu√© es una SAGA?

**Definici√≥n**: Una SAGA es una secuencia de transacciones locales donde cada transacci√≥n actualiza datos en un solo servicio. Si una transacci√≥n falla, la SAGA ejecuta transacciones compensatorias para deshacer los cambios.

**Paper original**: "Sagas" por Hector Garcia-Molina & Kenneth Salem (1987)

### 3.2 Tipos de SAGA

#### 3.2.1 SAGA con Orquestaci√≥n (Orchestration)

**Nuestro ejercicio usa este patr√≥n**

```mermaid
graph TB
    Client[Cliente] -->|POST /orders| Orchestrator[Order Service<br/>SAGA Orchestrator]
    
    Orchestrator -->|1. Reserve Stock| Inventory[Inventory Service]
    Inventory -->|OK/FAIL| Orchestrator
    
    Orchestrator -->|2. Process Payment| Payment[Payment Service]
    Payment -->|OK/FAIL| Orchestrator
    
    Orchestrator -->|3. Confirm Stock| Inventory
    Inventory -->|OK| Orchestrator
    
    Orchestrator -->|4. Save Order| DB[(Orders DB)]
    
    Orchestrator -->|Response| Client
    
    style Orchestrator fill:#4CAF50,stroke:#2E7D32,color:#fff
    style Inventory fill:#2196F3,stroke:#1565C0,color:#fff
    style Payment fill:#FF9800,stroke:#E65100,color:#fff
```

**Caracter√≠sticas:**
- ‚úÖ Un orquestador central coordina todo
- ‚úÖ L√≥gica de compensaci√≥n centralizada
- ‚úÖ F√°cil de entender y mantener
- ‚úÖ Buen para flujos complejos con muchas reglas de negocio
- ‚ùå Puede convertirse en un "god object"
- ‚ùå Punto √∫nico de fallo (mitigable con HA)

**C√≥digo del Orquestador (simplificado):**

```java
@ApplicationScoped
public class OrderSagaOrchestrator {
    
    public SagaResult executeSaga(Order order, String paymentMethod) {
        List<CompletedStep> steps = new ArrayList<>();
        
        try {
            // PASO 1: Reservar inventario
            for (OrderItem item : order.items) {
                inventoryClient.reserveStock(item);
                steps.add(new CompletedStep("INVENTORY", item));
            }
            
            // PASO 2: Procesar pago
            paymentClient.processPayment(order);
            steps.add(new CompletedStep("PAYMENT", order.id));
            
            // PASO 3: Confirmar inventario
            for (OrderItem item : order.items) {
                inventoryClient.confirmReservation(item);
            }
            
            // PASO 4: Marcar orden como completada
            order.status = COMPLETED;
            
            return SagaResult.success();
            
        } catch (Exception e) {
            // ‚ö†Ô∏è COMPENSACI√ìN: Deshacer en orden INVERSO
            compensate(steps);
            return SagaResult.failure(e.getMessage());
        }
    }
    
    private void compensate(List<CompletedStep> steps) {
        // Iterar en REVERSA (LIFO)
        for (int i = steps.size() - 1; i >= 0; i--) {
            CompletedStep step = steps.get(i);
            
            switch (step.type) {
                case "PAYMENT":
                    paymentClient.refund(step.orderId);
                    break;
                case "INVENTORY":
                    inventoryClient.cancelReservation(step.item);
                    break;
            }
        }
    }
}
```

**Analog√≠a**: Un jefe de proyecto (orquestador) asigna tareas:
- "Juan, haz X" ‚Üí Juan lo hace ‚Üí Jefe: "OK, Mar√≠a haz Y"
- Si Mar√≠a falla ‚Üí Jefe: "Juan, deshace X"

#### 3.2.2 SAGA con Coreograf√≠a (Choreography)

```mermaid
sequenceDiagram
    participant O as Order Service
    participant I as Inventory Service
    participant P as Payment Service
    participant E as Event Bus (Kafka)
    
    O->>E: OrderCreated Event
    E->>I: Consume Event
    I->>I: Reserve Stock
    I->>E: StockReserved Event
    
    E->>P: Consume Event
    P->>P: Process Payment
    P->>E: PaymentProcessed Event
    
    E->>I: Consume Event
    I->>I: Confirm Reservation
    I->>E: ReservationConfirmed Event
    
    Note over O,E: ‚ùå Si fallo: Eventos de compensaci√≥n
```

**Caracter√≠sticas:**
- ‚úÖ Sin punto √∫nico de fallo
- ‚úÖ Muy desacoplado
- ‚úÖ Cada servicio es aut√≥nomo
- ‚ùå Dif√≠cil de entender el flujo completo
- ‚ùå Dif√≠cil de debuggear
- ‚ùå L√≥gica de negocio distribuida

**Analog√≠a**: Un equipo de f√∫tbol sin entrenador:
- Cada jugador reacciona a lo que ve
- Si el portero atrapa el bal√≥n ‚Üí los defensas suben
- Si fallan ‚Üí cada uno compensa su posici√≥n
- ‚ùå Dif√≠cil coordinar jugadas complejas

### 3.3 Compensaciones: La Clave de SAGA

#### 3.3.1 Tipos de Operaciones

**1. Operaciones Compensables**
- Tienen una operaci√≥n inversa
- Ejemplo: `reserveStock()` ‚Üî `cancelReservation()`

**2. Operaciones Pivot**
- Punto de no retorno
- Ejemplo: Enviar email de confirmaci√≥n

**3. Operaciones Retriables**
- Pueden fallar temporalmente pero se pueden reintentar
- Ejemplo: Llamadas HTTP con timeout

#### 3.3.2 Dise√±o de Compensaciones

**Regla de Oro**: Las compensaciones deben ser **idempotentes** y **retriables**

```java
// ‚ùå MAL: No es idempotente
public void cancelReservation(String orderId) {
    int reserved = getReservedStock(orderId);
    stock += reserved;  // Si se llama 2 veces, suma 2 veces
}

// ‚úÖ BIEN: Idempotente
public void cancelReservation(String orderId) {
    Reservation res = reservations.get(orderId);
    if (res != null && res.status == RESERVED) {
        stock += res.quantity;
        res.status = CANCELLED;
    }
    // Si se llama 2 veces, solo act√∫a la primera vez
}
```

#### 3.3.3 Compensaciones en Nuestro Ejercicio

```java
private void compensate(Order order, List<SagaStep> completedSteps) {
    LOG.warn("üîÑ Iniciando compensaciones para orden: " + order.id);
    
    // ‚ö†Ô∏è IMPORTANTE: Recorrer en ORDEN INVERSO (LIFO)
    for (int i = completedSteps.size() - 1; i >= 0; i--) {
        SagaStep step = completedSteps.get(i);
        
        try {
            switch (step.stepType) {
                case "PAYMENT":
                    // Reembolsar dinero
                    paymentClient.refundPayment(order.id);
                    break;
                    
                case "INVENTORY_RESERVE":
                    // Liberar stock reservado
                    inventoryClient.cancelReservation(order.id, step.productCode);
                    break;
            }
        } catch (Exception e) {
            // ‚ö†Ô∏è En producci√≥n: enviar a cola de retry
            LOG.error("Error al compensar: " + step.stepType, e);
        }
    }
}
```

**¬øPor qu√© en orden inverso (LIFO)?**

Imagina que est√°s construyendo una torre de naipes:
1. Pones carta A
2. Pones carta B encima de A
3. Pones carta C encima de B

Si algo falla, debes quitar:
1. Primero C (√∫ltima puesta)
2. Luego B
3. Finalmente A

Si intentas quitar A primero ‚Üí ¬°La torre se cae!

### 3.4 Estados de una SAGA

```mermaid
stateDiagram-v2
    [*] --> PENDING: Orden creada
    PENDING --> INVENTORY_RESERVED: Stock reservado
    INVENTORY_RESERVED --> PAYMENT_PROCESSING: Pago en proceso
    PAYMENT_PROCESSING --> COMPLETED: Todo OK
    
    PENDING --> COMPENSATING: Fallo en reserva
    INVENTORY_RESERVED --> COMPENSATING: Fallo en pago
    PAYMENT_PROCESSING --> COMPENSATING: Fallo en confirmaci√≥n
    
    COMPENSATING --> FAILED: Compensaci√≥n completa
    FAILED --> [*]
    COMPLETED --> [*]
    
    note right of COMPENSATING
        Ejecutar compensaciones
        en orden INVERSO
    end note
```

### 3.5 Ventajas y Desventajas de SAGA

#### ‚úÖ Ventajas

1. **Escalabilidad**: Cada servicio puede escalar independientemente
2. **No hay bloqueos**: Transacciones locales, no bloqueantes
3. **Resiliente**: Si un servicio falla, los dem√°s contin√∫an
4. **Flexibilidad**: F√°cil agregar nuevos pasos

#### ‚ùå Desventajas

1. **Complejidad**: M√°s c√≥digo que 2PC
2. **Inconsistencia temporal**: Los datos pueden estar inconsistentes durante la SAGA
3. **Compensaciones complejas**: No todas las operaciones son compensables
4. **Testing dif√≠cil**: Muchos escenarios de fallo posibles

---

## 4. Redis Cache y Patrones de Cach√©

### 4.1 ¬øPor qu√© Redis?

**Redis** (REmote DIctionary Server) es una base de datos en memoria ultra-r√°pida.

**Comparaci√≥n de latencias:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Operaci√≥n              ‚îÇ Latencia     ‚îÇ Comparaci√≥n‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ L1 Cache               ‚îÇ 0.5 ns       ‚îÇ 1 segundo  ‚îÇ
‚îÇ Redis (local)          ‚îÇ 1-10 ms      ‚îÇ 1 semana   ‚îÇ
‚îÇ PostgreSQL (local)     ‚îÇ 50-100 ms    ‚îÇ 3 meses    ‚îÇ
‚îÇ HTTP API               ‚îÇ 100-500 ms   ‚îÇ 1 a√±o      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Redis es ~10-100x m√°s r√°pido que una BD tradicional
```

**Analog√≠a**: Redis es como tu memoria RAM vs el disco duro:
- **RAM (Redis)**: Acceso instant√°neo, pero vol√°til y limitado
- **Disco (PostgreSQL)**: M√°s lento, pero persistente y espacioso

### 4.2 Patrones de Cach√©

#### 4.2.1 Cache-Aside (Lazy Loading) - **NUESTRO PATR√ìN**

```mermaid
sequenceDiagram
    participant A as Aplicaci√≥n
    participant C as Redis Cache
    participant D as Base de Datos
    
    A->>C: GET product:123
    
    alt Cache HIT
        C-->>A: ‚úÖ Producto encontrado
        Note over A: Latencia: ~1ms
    else Cache MISS
        C-->>A: ‚ùå No encontrado
        A->>D: SELECT * FROM products WHERE id=123
        D-->>A: Producto
        Note over A: Latencia: ~50ms
        A->>C: SET product:123 = {data}
        Note over C: TTL: 10 minutos
    end
```

**Implementaci√≥n en nuestro ejercicio:**

```java
private ProductInfoDTO getProductWithCache(String productCode) {
    String cacheKey = PRODUCT_CACHE_PREFIX + productCode;
    
    // 1. Intentar obtener del cache (R√ÅPIDO ~1ms)
    ProductInfoDTO cached = productCache.get(cacheKey);
    if (cached != null) {
        LOG.debug("üéØ Cache HIT para producto: " + productCode);
        return cached;
    }
    
    // 2. Cache MISS - obtener del servicio (LENTO ~50ms)
    LOG.debug("‚ùå Cache MISS - consultando servicio");
    ProductInfoDTO product = inventoryClient.getProduct(productCode);
    
    // 3. Guardar en cache con TTL de 10 minutos
    SetArgs setArgs = new SetArgs().ex(Duration.ofMinutes(10));
    productCache.set(cacheKey, product, setArgs);
    
    return product;
}
```

**Ventajas:**
- ‚úÖ Simple de implementar
- ‚úÖ El cache solo contiene datos que realmente se usan
- ‚úÖ La aplicaci√≥n controla qu√© cachear

**Desventajas:**
- ‚ùå Primera consulta siempre es lenta (cache miss)
- ‚ùå Puede haber "thundering herd" (muchas consultas simult√°neas)

#### 4.2.2 Read-Through

```mermaid
sequenceDiagram
    participant A as Aplicaci√≥n
    participant C as Cache (con l√≥gica)
    participant D as Base de Datos
    
    A->>C: GET product:123
    
    alt Cache HIT
        C-->>A: ‚úÖ Producto
    else Cache MISS
        C->>D: Cargar autom√°ticamente
        D-->>C: Datos
        C->>C: Guardar
        C-->>A: Producto
    end
```

**Ventajas:**
- ‚úÖ L√≥gica de carga centralizada
- ‚úÖ Aplicaci√≥n m√°s simple

**Desventajas:**
- ‚ùå Requiere cache "inteligente"
- ‚ùå Menos flexible

#### 4.2.3 Write-Through

```mermaid
sequenceDiagram
    participant A as Aplicaci√≥n
    participant C as Cache
    participant D as Base de Datos
    
    A->>C: SET product:123 = {data}
    C->>D: Escribir en BD
    D-->>C: OK
    C->>C: Actualizar cache
    C-->>A: OK
    
    Note over A,D: Siempre sincronizado
```

**Ventajas:**
- ‚úÖ Datos siempre frescos
- ‚úÖ Consistencia fuerte

**Desventajas:**
- ‚ùå Escrituras lentas (doble escritura)
- ‚ùå Puede cachear datos que nunca se leen

#### 4.2.4 Write-Behind (Write-Back)

```mermaid
sequenceDiagram
    participant A as Aplicaci√≥n
    participant C as Cache
    participant D as Base de Datos
    
    A->>C: SET product:123 = {data}
    C-->>A: ‚úÖ OK (inmediato)
    
    Note over C: Acumula escrituras
    
    C->>D: Batch de escrituras
    D-->>C: OK
```

**Ventajas:**
- ‚úÖ Escrituras ultra-r√°pidas
- ‚úÖ Reduce carga en BD (batch)

**Desventajas:**
- ‚ùå Riesgo de p√©rdida de datos si cache falla
- ‚ùå Complejidad alta

### 4.3 TTL (Time To Live) y Eviction

**TTL**: Tiempo que un dato permanece en cache antes de expirar.

```java
// Configurar TTL en Redis
SetArgs args = new SetArgs()
    .ex(Duration.ofMinutes(10));  // Expira en 10 minutos

cache.set(key, value, args);
```

**Pol√≠ticas de Eviction** (cuando el cache se llena):

| Pol√≠tica | Descripci√≥n | Uso |
|----------|-------------|-----|
| **LRU** (Least Recently Used) | Elimina lo menos usado recientemente | General purpose ‚úÖ |
| **LFU** (Least Frequently Used) | Elimina lo menos frecuentemente usado | Datos con patrones de acceso claros |
| **FIFO** (First In First Out) | Elimina lo m√°s antiguo | Datos temporales |
| **Random** | Elimina aleatoriamente | Testing, casos simples |

```
# Redis configuration
maxmemory 256mb
maxmemory-policy allkeys-lru  # Recomendado para cache general
```

### 4.4 Cache Invalidation: "El problema m√°s dif√≠cil"

> "There are only two hard things in Computer Science: cache invalidation and naming things."  
> ‚Äî Phil Karlton

#### Estrategias de Invalidaci√≥n

**1. TTL-based (Nuestro enfoque)**
```java
// Cache expira autom√°ticamente despu√©s de 10 minutos
SetArgs args = new SetArgs().ex(Duration.ofMinutes(10));
```

**Pros:**
- ‚úÖ Simple
- ‚úÖ Previene datos obsoletos extremadamente viejos

**Cons:**
- ‚ùå Puede servir datos obsoletos durante el TTL
- ‚ùå No es √≥ptimo para datos cr√≠ticos

**2. Event-based Invalidation**
```java
// Cuando se actualiza un producto en Inventory Service
@Transactional
public void updateProduct(Product product) {
    productRepository.persist(product);
    
    // Publicar evento
    eventBus.publish(new ProductUpdatedEvent(product.code));
}

// Order Service escucha y invalida
@Incoming("product-updates")
public void onProductUpdated(ProductUpdatedEvent event) {
    orderService.invalidateProductCache(event.productCode);
}
```

**Pros:**
- ‚úÖ Invalidaci√≥n inmediata
- ‚úÖ Consistencia m√°s fuerte

**Cons:**
- ‚ùå Complejidad adicional (event bus)
- ‚ùå Posible p√©rdida de eventos

**3. Write-Through (sincron√≠a forzada)**
```java
public void updateProduct(Product product) {
    // 1. Actualizar BD
    productRepository.persist(product);
    
    // 2. Actualizar cache inmediatamente
    cache.set(cacheKey, product);
}
```

**Pros:**
- ‚úÖ Siempre consistente

**Cons:**
- ‚ùå Acoplamiento fuerte
- ‚ùå M√°s lento

### 4.5 Cache Stampede (Thundering Herd)

**Problema**: Cuando muchas solicitudes golpean un cache miss simult√°neamente.

```
Cache expira a las 10:00:00

10:00:00.001 ‚Üí Request 1: Cache MISS ‚Üí Consulta BD
10:00:00.002 ‚Üí Request 2: Cache MISS ‚Üí Consulta BD
10:00:00.003 ‚Üí Request 3: Cache MISS ‚Üí Consulta BD
...
10:00:00.100 ‚Üí Request 100: Cache MISS ‚Üí Consulta BD

‚ùå 100 consultas a la BD simult√°neas! (podr√≠a caer)
```

**Soluci√≥n 1: Locking (Probabilistic Early Expiration)**

```java
public ProductInfoDTO getWithLock(String productCode) {
    String lockKey = "lock:" + productCode;
    
    // Intentar obtener lock
    boolean gotLock = redisClient.setnx(lockKey, "1", Duration.ofSeconds(5));
    
    if (gotLock) {
        try {
            // Solo este thread consulta la BD
            ProductInfoDTO product = inventoryClient.getProduct(productCode);
            cache.set(cacheKey, product);
            return product;
        } finally {
            redisClient.del(lockKey);
        }
    } else {
        // Otros threads esperan un poco y reintentan cache
        Thread.sleep(100);
        return cache.get(cacheKey);
    }
}
```

**Soluci√≥n 2: Probabilistic Early Expiration**

```java
public ProductInfoDTO getWithProbabilisticRefresh(String productCode) {
    ProductInfoDTO cached = cache.get(cacheKey);
    
    if (cached != null) {
        long timeToExpire = cache.ttl(cacheKey);
        long ttl = Duration.ofMinutes(10).toSeconds();
        
        // Probabilidad = delta * beta * log(rand)
        double delta = System.currentTimeMillis() / 1000.0;
        double beta = 1.0;
        double probability = delta * beta * Math.log(Math.random());
        
        if (timeToExpire < probability) {
            // Refrescar proactivamente
            asyncRefresh(productCode);
        }
        
        return cached;
    }
    
    // Cache miss normal
    return loadAndCache(productCode);
}
```

### 4.6 M√©tricas de Cache

**Indicadores clave:**

```java
public class CacheMetrics {
    private AtomicLong hits = new AtomicLong(0);
    private AtomicLong misses = new AtomicLong(0);
    
    public double getHitRate() {
        long totalRequests = hits.get() + misses.get();
        if (totalRequests == 0) return 0.0;
        return (double) hits.get() / totalRequests;
    }
    
    public void recordHit() { hits.incrementAndGet(); }
    public void recordMiss() { misses.incrementAndGet(); }
}

// Monitorear
LOG.info("Cache Hit Rate: " + metrics.getHitRate() * 100 + "%");
```

**Hit Rate ideal:**
- ‚úÖ > 80%: Excelente
- ‚ö†Ô∏è 50-80%: Aceptable
- ‚ùå < 50%: Revisar estrategia de cache

---

## 5. Circuit Breaker y Fault Tolerance

### 5.1 El Problema: Fallos en Cascada

```
User Request
    ‚îÇ
    ‚ñº
Order Service (OK)
    ‚îÇ
    ‚ñº
Inventory Service (LENTO - 30s timeout)
    ‚îÇ
    ‚ñº
‚ùå Todos los threads del Order Service bloqueados esperando
‚ùå Order Service se cae por falta de recursos
‚ùå Otros servicios que dependen de Order Service tambi√©n fallan
‚ùå EFECTO DOMIN√ì
```

**Analog√≠a**: Es como un fusible en tu casa:
- Si un electrodom√©stico falla y consume mucha corriente
- El fusible "se abre" (circuit breaker)
- Protege el resto del sistema el√©ctrico

### 5.2 Estados del Circuit Breaker

```mermaid
stateDiagram-v2
    [*] --> CLOSED: Inicio
    
    CLOSED --> OPEN: Muchos fallos<br/>(threshold superado)
    OPEN --> HALF_OPEN: Despu√©s de timeout
    HALF_OPEN --> CLOSED: Requests OK
    HALF_OPEN --> OPEN: Fallo detectado
    
    note right of CLOSED
        Estado normal
        Todas las requests pasan
        Se cuentan fallos
    end note
    
    note right of OPEN
        Circuito abierto
        Requests fallan inmediatamente
        No se llama al servicio
    end note
    
    note right of HALF_OPEN
        Modo de prueba
        Permite algunas requests
        Decide si volver a CLOSED
    end note
```

### 5.3 Implementaci√≥n con Quarkus

```java
@CircuitBreaker(
    requestVolumeThreshold = 4,        // M√≠nimo 4 requests para evaluar
    failureRatio = 0.5,                // 50% de fallos = abrir circuito
    delay = 5000,                      // Esperar 5s antes de HALF_OPEN
    successThreshold = 2               // 2 √©xitos en HALF_OPEN = cerrar
)
@Timeout(value = 30, unit = ChronoUnit.SECONDS)
@Fallback(fallbackMethod = "fallbackExecuteSaga")
public SagaResult executeSaga(Order order, String paymentMethod) {
    // L√≥gica normal
}

// M√©todo fallback cuando el circuit est√° OPEN
public SagaResult fallbackExecuteSaga(Order order, String paymentMethod) {
    LOG.error("‚ö†Ô∏è Circuit Breaker ABIERTO - Sistema bajo estr√©s");
    return SagaResult.failure(order.id, 
        "Servicio temporalmente no disponible");
}
```

**Par√°metros explicados:**

| Par√°metro | Significado | Valor en ejercicio |
|-----------|-------------|---------------------|
| `requestVolumeThreshold` | N√∫mero m√≠nimo de requests para calcular failure ratio | 4 |
| `failureRatio` | % de fallos para abrir el circuito | 0.5 (50%) |
| `delay` | Tiempo en OPEN antes de ir a HALF_OPEN | 5000ms (5s) |
| `successThreshold` | √âxitos consecutivos en HALF_OPEN para CERRAR | 2 |

**Ejemplo de flujo:**

```
Request 1: ‚úÖ OK       (ratio: 0/1 = 0%)
Request 2: ‚úÖ OK       (ratio: 0/2 = 0%)
Request 3: ‚ùå FALLO    (ratio: 1/3 = 33%)
Request 4: ‚ùå FALLO    (ratio: 2/4 = 50%) ‚Üí ‚ö° CIRCUITO ABRE

Request 5-20: ‚ö†Ô∏è Fallback inmediato (no llama al servicio)

[Despu√©s de 5 segundos]
Estado: HALF_OPEN
Request 21: ‚úÖ OK      (1 √©xito)
Request 22: ‚úÖ OK      (2 √©xitos) ‚Üí ‚úÖ CIRCUITO CIERRA

Request 23: ‚úÖ OK      (funcionando normal)
```

### 5.4 Bulkhead Pattern

**Problema**: Un servicio lento consume todos los threads disponibles.

```java
@Bulkhead(value = 5, waitingTaskQueue = 10)
public Response processOrder(Order order) {
    // M√°ximo 5 ejecuciones concurrentes
    // 10 en cola de espera
    // El resto: fallo inmediato
}
```

**Analog√≠a**: Es como los compartimentos estancos de un barco:
- Si un compartimento se inunda (un servicio falla)
- Los dem√°s compartimentos siguen secos (otros servicios funcionan)

### 5.5 Retry Pattern

```java
@Retry(
    maxRetries = 3,
    delay = 1000,
    jitter = 500
)
public Product getProduct(String code) {
    // Reintenta hasta 3 veces
    // Espera 1000ms + random(0-500ms) entre reintentos
}
```

**Jitter**: Variaci√≥n aleatoria para evitar "thundering herd"

```
Sin jitter:
Request 1: intento en 0s, 1s, 2s, 3s
Request 2: intento en 0s, 1s, 2s, 3s
Request 3: intento en 0s, 1s, 2s, 3s
‚ùå Todos golpean al mismo tiempo

Con jitter:
Request 1: intento en 0s, 1.2s, 2.4s, 3.1s
Request 2: intento en 0s, 1.5s, 2.1s, 3.5s
Request 3: intento en 0s, 1.8s, 2.7s, 3.2s
‚úÖ Distribuidos en el tiempo
```

---

## 6. Consistencia Eventual

### 6.1 ¬øQu√© es Consistencia Eventual?

**Definici√≥n**: Los datos eventualmente ser√°n consistentes, pero pueden estar temporalmente inconsistentes.

**Analog√≠a**: Es como Wikipedia:
- Alguien edita un art√≠culo ‚Üí Cambio inmediato en un servidor
- Replicaci√≥n a otros servidores ‚Üí Toma algunos segundos
- Durante esos segundos ‚Üí Usuarios en diferentes regiones ven versiones diferentes
- Eventualmente ‚Üí Todos ven la misma versi√≥n

### 6.2 Ventana de Inconsistencia en nuestro SAGA

```
T0: Cliente crea orden
    ‚îÇ
    ‚îú‚îÄ Order DB: PENDING
    ‚îú‚îÄ Inventory DB: Stock = 100
    ‚îî‚îÄ Payment DB: No hay registro
    
T1: Reservar inventario (50ms)
    ‚îÇ
    ‚îú‚îÄ Order DB: INVENTORY_RESERVED
    ‚îú‚îÄ Inventory DB: Stock = 100, Reserved = 10  ‚ö†Ô∏è INCONSISTENTE
    ‚îî‚îÄ Payment DB: No hay registro              ‚ö†Ô∏è INCONSISTENTE
    
T2: Procesar pago (100ms)
    ‚îÇ
    ‚îú‚îÄ Order DB: PAYMENT_PROCESSING
    ‚îú‚îÄ Inventory DB: Stock = 100, Reserved = 10
    ‚îî‚îÄ Payment DB: Payment = APPROVED           ‚ö†Ô∏è INCONSISTENTE
    
T3: Confirmar inventario (30ms)
    ‚îÇ
    ‚îú‚îÄ Order DB: COMPLETED
    ‚îú‚îÄ Inventory DB: Stock = 90, Reserved = 0   ‚úÖ CONSISTENTE
    ‚îî‚îÄ Payment DB: Payment = APPROVED           ‚úÖ CONSISTENTE

Ventana de inconsistencia: T0 ‚Üí T3 (180ms)
```

### 6.3 Patrones para Manejar Consistencia Eventual

#### 6.3.1 Compensating Transactions (Ya visto en SAGA)

#### 6.3.2 Event Sourcing

**Idea**: No guardar el estado actual, sino la secuencia de eventos.

```java
// ‚ùå Estado actual (Traditional)
Order {
    id: "123",
    status: "COMPLETED",
    total: 1000
}

// ‚úÖ Event Sourcing
OrderCreated {
    orderId: "123",
    userId: "user-1",
    timestamp: T0
}

InventoryReserved {
    orderId: "123",
    productCode: "LAPTOP-001",
    quantity: 1,
    timestamp: T1
}

PaymentProcessed {
    orderId: "123",
    amount: 1000,
    timestamp: T2
}

OrderCompleted {
    orderId: "123",
    timestamp: T3
}

// Estado actual = replay de todos los eventos
```

**Ventajas:**
- ‚úÖ Auditor√≠a completa
- ‚úÖ Reconstruir estado en cualquier momento
- ‚úÖ F√°cil debugging

**Desventajas:**
- ‚ùå Complejidad alta
- ‚ùå Almacenamiento grande
- ‚ùå Queries complejas

#### 6.3.3 CQRS (Command Query Responsibility Segregation)

**Idea**: Separar lecturas (queries) de escrituras (commands).

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   COMMAND    ‚îÇ          ‚îÇ     QUERY     ‚îÇ
‚îÇ   (Write)    ‚îÇ          ‚îÇ     (Read)    ‚îÇ
‚îÇ              ‚îÇ          ‚îÇ               ‚îÇ
‚îÇ createOrder()‚îÇ          ‚îÇ getOrder()    ‚îÇ
‚îÇ updateOrder()‚îÇ          ‚îÇ listOrders()  ‚îÇ
‚îÇ              ‚îÇ          ‚îÇ               ‚îÇ
‚îÇ Write DB     ‚îÇ‚îÄ‚îÄEvents‚îÄ‚ñ∂‚îÇ Read DB       ‚îÇ
‚îÇ (PostgreSQL) ‚îÇ          ‚îÇ (ElasticSearch‚îÇ
‚îÇ Normalizado  ‚îÇ          ‚îÇ  o Redis)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 6.4 Niveles de Consistencia

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Consistencia Fuerte (Strong Consistency)            ‚îÇ
‚îÇ ‚Ä¢ 2PC, distributed locks                            ‚îÇ
‚îÇ ‚Ä¢ Latencia alta                                     ‚îÇ
‚îÇ ‚Ä¢ Disponibilidad baja                               ‚îÇ
‚îÇ Ejemplo: Transferencia bancaria                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Consistencia Eventual (Eventual Consistency)        ‚îÇ
‚îÇ ‚Ä¢ SAGA, Event Sourcing                              ‚îÇ
‚îÇ ‚Ä¢ Latencia media                                    ‚îÇ
‚îÇ ‚Ä¢ Disponibilidad alta                               ‚îÇ
‚îÇ Ejemplo: Contador de likes en redes sociales        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Consistencia Causal (Causal Consistency)            ‚îÇ
‚îÇ ‚Ä¢ Respeta orden de operaciones relacionadas         ‚îÇ
‚îÇ ‚Ä¢ Latencia baja-media                               ‚îÇ
‚îÇ ‚Ä¢ Disponibilidad alta                               ‚îÇ
‚îÇ Ejemplo: Mensajer√≠a (respuestas despu√©s de mensajes)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**¬øCu√°l usar?**

| Escenario | Tipo de Consistencia |
|-----------|---------------------|
| Transferencia de dinero | Fuerte |
| Actualizar perfil de usuario | Eventual |
| Sistema de reservas de vuelos | Fuerte |
| Feed de noticias | Eventual |
| Carrito de compras | Eventual |
| Pago con tarjeta | Fuerte |

---

## 7. Comparaciones y Trade-offs

### 7.1 SAGA vs 2PC

| Caracter√≠stica | 2PC | SAGA |
|----------------|-----|------|
| **Bloqueos** | S√≠, largo plazo | No |
| **Disponibilidad** | Baja | Alta |
| **Escalabilidad** | Baja (O(n¬≤)) | Alta (O(n)) |
| **Consistencia** | Fuerte | Eventual |
| **Complejidad** | Protocolo complejo | L√≥gica de compensaci√≥n compleja |
| **Uso recomendado** | Sistemas peque√±os, transacciones cr√≠ticas | Microservicios, alta escala |

### 7.2 Orquestaci√≥n vs Coreograf√≠a

| Aspecto | Orquestaci√≥n | Coreograf√≠a |
|---------|--------------|-------------|
| **Complejidad de entender** | Baja (flujo centralizado) | Alta (flujo distribuido) |
| **Punto √∫nico de fallo** | S√≠ (orquestador) | No |
| **Acoplamiento** | Alto (conoce todos los servicios) | Bajo (eventos) |
| **Debugging** | F√°cil | Dif√≠cil |
| **Cambios en flujo** | F√°cil (un solo lugar) | Dif√≠cil (m√∫ltiples servicios) |
| **Mejor para** | Flujos complejos de negocio | Sistemas event-driven simples |

### 7.3 Cache-Aside vs Write-Through

| Aspecto | Cache-Aside | Write-Through |
|---------|-------------|---------------|
| **Latencia de lectura (hit)** | Baja | Baja |
| **Latencia de lectura (miss)** | Alta | Alta |
| **Latencia de escritura** | Media (solo BD) | Alta (BD + cache) |
| **Consistencia** | Eventual (seg√∫n TTL) | Fuerte |
| **Complejidad** | Baja | Media |
| **Uso eficiente de cache** | S√≠ (solo datos usados) | No (datos no le√≠dos tambi√©n) |

---

## 8. Casos de Uso Reales

### 8.1 Netflix: Circuit Breaker Hystrix

Netflix procesa **2 mil millones de requests por d√≠a**. Usan Circuit Breaker para:

```java
@HystrixCommand(fallbackMethod = "getRecommendationsFallback")
public List<Movie> getRecommendations(User user) {
    // Llama a servicio de ML
    return mlService.getRecommendations(user.id);
}

public List<Movie> getRecommendationsFallback(User user) {
    // Fallback: pel√≠culas populares gen√©ricas
    return movieService.getPopularMovies();
}
```

**Resultado**:
- ‚úÖ Si el servicio de ML falla ‚Üí Usuario ve pel√≠culas populares (degradaci√≥n elegante)
- ‚úÖ El sistema sigue funcionando
- ‚úÖ No hay "pantalla blanca de error"

### 8.2 Amazon: SAGA para pedidos

**Flujo de Amazon (simplificado):**

```
1. Reservar inventario en warehouse
2. Autorizar pago con tarjeta
3. Asignar a transportista
4. Generar etiqueta de env√≠o
5. Notificar al cliente

Si falla en paso 3 (sin transportista disponible):
COMPENSACI√ìN:
- Cancelar etiqueta
- Liberar asignaci√≥n
- Reembolsar pre-autorizaci√≥n
- Liberar inventario
- Notificar al cliente
```

**Ventaja**: Procesar millones de pedidos sin bloqueos.

### 8.3 Twitter: Redis para Timeline

Twitter usa Redis para cachear **timelines de usuarios**:

```
GET timeline:user:123

Si cache HIT ‚Üí Devolver inmediatamente
Si cache MISS ‚Üí Consultar Cassandra ‚Üí Guardar en Redis (TTL 5 min)
```

**Resultados**:
- ‚úÖ Latencia de timeline: 50ms ‚Üí 5ms (10x m√°s r√°pido)
- ‚úÖ Reducci√≥n de carga en Cassandra: 90%
- ‚úÖ Ahorro de costos en infraestructura: millones de d√≥lares

### 8.4 Uber: Consistencia Eventual en precios

Cuando solicitas un Uber:

```
T0: App muestra precio estimado $10
    ‚îÇ
    ‚îî‚îÄ Servicio de Pricing calcula basado en demanda actual
    
T1: Usuario acepta el viaje
    ‚îÇ
    ‚îî‚îÄ Demand aument√≥ ‚Üí Precio real ahora es $12
    
T2: Sistema recalcula
    ‚îÇ
    ‚îî‚îÄ Uber absorbe diferencia o notifica al usuario
```

**Estrategia de Uber**:
- Usar **consistencia eventual** para estimaciones
- Usar **consistencia fuerte** para cobro final
- Degradaci√≥n elegante: si servicio de pricing falla ‚Üí usar precio promedio hist√≥rico

---

## 9. Mejores Pr√°cticas

### 9.1 Para SAGA

#### ‚úÖ DO

1. **Dise√±a compensaciones desde el inicio**
   ```java
   // Por cada operaci√≥n, piensa en su compensaci√≥n
   void reserveInventory(...)  ‚Üí void cancelReservation(...)
   void processPayment(...)    ‚Üí void refundPayment(...)
   void sendEmail(...)         ‚Üí void sendCancellationEmail(...)
   ```

2. **Usa estados intermedios claros**
   ```java
   enum OrderStatus {
       PENDING,
       INVENTORY_RESERVED,    // ‚úÖ Estado intermedio claro
       PAYMENT_PROCESSING,    // ‚úÖ Estado intermedio claro
       COMPLETED,
       FAILED
   }
   ```

3. **Haz las compensaciones idempotentes**
   ```java
   void cancelReservation(String orderId) {
       if (reservation.exists(orderId) && reservation.status == ACTIVE) {
           // Solo cancela si existe y est√° activa
           reservation.cancel();
       }
       // Llamar 2 veces no causa problemas
   }
   ```

4. **Monitorea el estado de tus SAGAs**
   ```java
   @Timed(name = "saga_execution_time")
   @Counted(name = "saga_executions_total")
   public SagaResult executeSaga(...) {
       // M√©tricas autom√°ticas
   }
   ```

5. **Implementa timeouts apropiados**
   ```java
   @Timeout(value = 30, unit = ChronoUnit.SECONDS)
   public SagaResult executeSaga(...) {
       // No esperar indefinidamente
   }
   ```

#### ‚ùå DON'T

1. **No asumas que las compensaciones siempre funcionan**
   ```java
   // ‚ùå MAL
   void compensate(...) {
       refundPayment();  // ¬øQu√© pasa si esto falla?
   }
   
   // ‚úÖ BIEN
   void compensate(...) {
       try {
           refundPayment();
       } catch (Exception e) {
           // Enviar a dead letter queue
           dlq.send(new CompensationFailedEvent(orderId, "REFUND"));
           // Alertar a equipo de soporte
           alerting.sendAlert("Compensaci√≥n manual requerida: " + orderId);
       }
   }
   ```

2. **No uses SAGA para operaciones que requieren consistencia fuerte**
   ```java
   // ‚ùå NO uses SAGA para:
   // - Transferencias bancarias entre cuentas
   // - Emisi√≥n de certificados digitales
   // - Operaciones que no pueden ser compensadas
   ```

3. **No olvides logging detallado**
   ```java
   // ‚ùå MAL
   LOG.info("Procesando orden");
   
   // ‚úÖ BIEN
   LOG.info("üöÄ Iniciando SAGA para orden: {} usuario: {}", 
            order.id, order.userId);
   LOG.info("üì¶ PASO 1/3: Reservando inventario para {} items", 
            order.items.size());
   ```

### 9.2 Para Redis Cache

#### ‚úÖ DO

1. **Define TTLs apropiados seg√∫n el tipo de dato**
   ```java
   // Datos de producto: cambian poco
   SetArgs args = new SetArgs().ex(Duration.ofHours(1));
   
   // Precio promocional: cambia frecuentemente
   SetArgs args = new SetArgs().ex(Duration.ofMinutes(5));
   
   // Sesi√≥n de usuario: duraci√≥n de la sesi√≥n
   SetArgs args = new SetArgs().ex(Duration.ofMinutes(30));
   ```

2. **Usa namespaces/prefijos para organizar claves**
   ```java
   String productKey = "product:" + productCode;
   String userKey = "user:session:" + userId;
   String orderKey = "order:summary:" + orderId;
   
   // F√°cil de buscar: KEYS product:*
   ```

3. **Monitorea cache hit rate**
   ```java
   @Scheduled(every = "1m")
   void logCacheStats() {
       double hitRate = cacheMetrics.getHitRate();
       if (hitRate < 0.7) {
           LOG.warn("‚ö†Ô∏è Cache hit rate bajo: {}%", hitRate * 100);
       }
   }
   ```

4. **Implementa fallback cuando Redis falla**
   ```java
   ProductInfoDTO getProduct(String code) {
       try {
           ProductInfoDTO cached = cache.get(code);
           if (cached != null) return cached;
       } catch (RedisException e) {
           LOG.warn("Redis no disponible, consultando directamente BD");
       }
       
       // Fallback: consultar BD directamente
       return inventoryService.getProduct(code);
   }
   ```

5. **Usa conexiones pooling**
   ```properties
   # application.properties
   quarkus.redis.max-pool-size=20
   quarkus.redis.max-pool-waiting=10
   ```

#### ‚ùå DON'T

1. **No caches datos sensibles sin cifrado**
   ```java
   // ‚ùå NUNCA hagas esto
   cache.set("user:password:" + userId, plainPassword);
   
   // ‚úÖ Si necesitas cachear datos sensibles, cifra
   String encrypted = encrypt(sensitiveData);
   cache.set(key, encrypted);
   ```

2. **No uses Redis como base de datos primaria**
   ```java
   // ‚ùå MAL
   // Solo guardar en Redis, confiar en la persistencia de Redis
   
   // ‚úÖ BIEN
   // Guardar en BD (fuente de verdad)
   // Cachear en Redis (optimizaci√≥n)
   ```

3. **No uses claves muy largas**
   ```java
   // ‚ùå MAL (desperdicia memoria)
   String key = "order:user:12345:product:LAPTOP-001:quantity:10:date:2024-01-01";
   
   // ‚úÖ BIEN
   String key = "ord:12345:LAPTOP";
   ```

### 9.3 Para Circuit Breaker

#### ‚úÖ DO

1. **Define thresholds basados en m√©tricas reales**
   ```java
   // Analiza logs de producci√≥n para definir:
   // - ¬øCu√°ntos fallos son normales?
   // - ¬øCu√°nto tiempo tarda en recuperarse el servicio?
   
   @CircuitBreaker(
       failureRatio = 0.5,        // 50% basado en an√°lisis
       delay = 5000               // 5s basado en tiempo de recuperaci√≥n
   )
   ```

2. **Implementa fallbacks significativos**
   ```java
   // ‚úÖ BIEN: Degradaci√≥n elegante
   public List<Product> getRecommendations(User user) {
       // Servicio de ML
   }
   
   public List<Product> fallbackRecommendations(User user) {
       // Fallback: productos populares de la categor√≠a favorita
       return popularProductsService.getByCategory(user.favoriteCategory);
   }
   ```

3. **Monitorea el estado del circuito**
   ```java
   @Scheduled(every = "30s")
   void checkCircuitBreakerStatus() {
       CircuitBreakerStatus status = circuitBreaker.getStatus();
       
       if (status == OPEN) {
           LOG.error("‚ö†Ô∏è Circuit Breaker ABIERTO: order-saga");
           alerting.sendAlert("Circuit breaker abierto");
       }
   }
   ```

#### ‚ùå DON'T

1. **No uses Circuit Breaker para errores de l√≥gica de negocio**
   ```java
   // ‚ùå NO abras el circuito por errores esperados
   if (stock < quantity) {
       throw new InsufficientStockException();  // Error de negocio normal
   }
   
   // ‚úÖ Solo para fallos t√©cnicos
   try {
       return httpClient.call(url);
   } catch (TimeoutException | ConnectionException e) {
       // Estos s√≠ deber√≠an contar para Circuit Breaker
   }
   ```

---

## 10. Antipatrones Comunes

### 10.1 God Orchestrator

**‚ùå Problema**: El orquestador sabe demasiado sobre la l√≥gica interna de cada servicio.

```java
// ‚ùå MAL: Orquestador con l√≥gica de negocio de otros servicios
public SagaResult executeSaga(Order order) {
    // Orquestador calculando descuentos (deber√≠a ser del Payment Service)
    double discount = 0;
    if (order.totalAmount > 1000) {
        discount = order.totalAmount * 0.1;
    }
    
    // Orquestador validando stock (deber√≠a ser del Inventory Service)
    for (OrderItem item : order.items) {
        Product product = inventoryDB.getProduct(item.productCode);
        if (product.stock < item.quantity) {
            return SagaResult.failure("Stock insuficiente");
        }
    }
}

// ‚úÖ BIEN: Orquestador solo coordina
public SagaResult executeSaga(Order order) {
    // Delega validaci√≥n al servicio correspondiente
    InventoryResponse invResp = inventoryClient.reserveStock(order);
    if (!invResp.success) {
        return SagaResult.failure(invResp.message);
    }
    
    // Delega c√°lculo de precio al servicio correspondiente
    PaymentResponse payResp = paymentClient.processPayment(order);
    if (!payResp.success) {
        compensate();
        return SagaResult.failure(payResp.message);
    }
}
```

### 10.2 Cache Everything (Cachear todo)

**‚ùå Problema**: Cachear datos que cambian frecuentemente o que rara vez se consultan.

```java
// ‚ùå MAL: Cachear precio de acciones (cambia cada segundo)
cache.set("stock:AAPL:price", currentPrice, Duration.ofMinutes(10));

// ‚ùå MAL: Cachear datos √∫nicos que se consultan solo una vez
cache.set("order:one-time:" + uuid, orderData);

// ‚úÖ BIEN: Cachear solo datos frecuentes y relativamente estables
cache.set("product:info:" + productCode, productInfo, Duration.ofHours(1));
cache.set("user:profile:" + userId, userProfile, Duration.ofMinutes(30));
```

### 10.3 Retry Infinito

**‚ùå Problema**: Reintentar indefinidamente una operaci√≥n que siempre falla.

```java
// ‚ùå MAL
@Retry(maxRetries = Integer.MAX_VALUE)
public Product getProduct(String code) {
    // Si el servicio est√° ca√≠do, reintentar√° para siempre
}

// ‚úÖ BIEN
@Retry(
    maxRetries = 3,
    delay = 1000,
    abortOn = {NotFoundException.class}  // No reintentar si no existe
)
public Product getProduct(String code) {
    // Reintenta solo errores temporales
}
```

### 10.4 Compensaciones No Idempotentes

**‚ùå Problema**: Ejecutar una compensaci√≥n m√∫ltiples veces causa efectos secundarios.

```java
// ‚ùå MAL: No es idempotente
public void refundPayment(String orderId) {
    double amount = getPaymentAmount(orderId);
    account.balance += amount;  // Si se llama 2 veces, suma 2 veces
}

// ‚úÖ BIEN: Idempotente
public void refundPayment(String orderId) {
    Payment payment = payments.get(orderId);
    
    if (payment != null && payment.status == PAID) {
        account.balance += payment.amount;
        payment.status = REFUNDED;
        payments.update(payment);
    }
    // Segunda llamada no hace nada (ya est√° REFUNDED)
}
```

### 10.5 Ignorar Cache Invalidation

**‚ùå Problema**: Datos obsoletos en cache porque nunca se invalidan.

```java
// ‚ùå MAL
public void updateProduct(Product product) {
    productRepository.update(product);
    // Cache nunca se invalida ‚Üí usuarios ven datos viejos
}

// ‚úÖ BIEN: Invalidar o actualizar cache
public void updateProduct(Product product) {
    productRepository.update(product);
    
    // Opci√≥n 1: Invalidar
    cache.del("product:" + product.code);
    
    // Opci√≥n 2: Actualizar
    cache.set("product:" + product.code, product);
}
```

---

## 11. Referencias y Recursos

### üìö Papers Acad√©micos

1. **Sagas (1987)**
   - Autores: Hector Garcia-Molina, Kenneth Salem
   - Link: https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf
   - *El paper original que define el patr√≥n SAGA*

2. **BASE: An Acid Alternative (2008)**
   - Autor: Dan Pritchett
   - *Introduce las propiedades BASE para sistemas distribuidos*

3. **CAP Theorem (2000)**
   - Autor: Eric Brewer
   - *Teorema fundamental de sistemas distribuidos*

### üìñ Libros Recomendados

1. **"Microservices Patterns" - Chris Richardson**
   - Cap√≠tulo 4: Managing transactions with sagas
   - ISBN: 9781617294549

2. **"Designing Data-Intensive Applications" - Martin Kleppmann**
   - Cap√≠tulo 7: Transactions
   - Cap√≠tulo 9: Consistency and Consensus
   - ISBN: 9781449373320

3. **"Building Microservices" - Sam Newman (2nd Edition)**
   - Cap√≠tulo 6: Workflow
   - ISBN: 9781492034025

### üé• Talks y Videos

1. **"Sagas" - Caitie McCaffrey (2015)**
   - https://www.youtube.com/watch?v=xDuwrtwYHu8
   - *Excelente explicaci√≥n pr√°ctica del patr√≥n SAGA*

2. **"Designing for Failure" - Netflix**
   - *Circuit Breaker y Fault Tolerance en producci√≥n*

### üîß Herramientas y Frameworks

1. **Quarkus SmallRye Fault Tolerance**
   - https://quarkus.io/guides/smallrye-fault-tolerance
   - *Nuestra biblioteca para Circuit Breaker*

2. **Redis**
   - https://redis.io/documentation
   - *Documentaci√≥n oficial de Redis*

3. **Saga Pattern en Microservices.io**
   - https://microservices.io/patterns/data/saga.html
   - *Referencia completa del patr√≥n*

### üìä Casos de Estudio

1. **Uber: Cadence (Orquestador de Workflows)**
   - https://cadenceworkflow.io/
   - *Framework de Uber para SAGAs complejas*

2. **Netflix: Conductor**
   - https://netflix.github.io/conductor/
   - *Orquestador de microservicios de Netflix*

3. **Amazon: Step Functions**
   - https://aws.amazon.com/step-functions/
   - *Servicio de AWS para orquestaci√≥n de workflows*

### üéØ M√©tricas y Monitoreo

**M√©tricas clave para monitorear:**

1. **SAGA Metrics**
   ```
   - saga.execution.time (p50, p95, p99)
   - saga.success.rate
   - saga.compensation.rate
   - saga.step.duration (por cada paso)
   ```

2. **Cache Metrics**
   ```
   - cache.hit.rate
   - cache.miss.rate
   - cache.eviction.rate
   - cache.memory.usage
   ```

3. **Circuit Breaker Metrics**
   ```
   - circuit.breaker.state (closed/open/half-open)
   - circuit.breaker.failure.rate
   - circuit.breaker.call.duration
   ```

---

## üéì Conclusi√≥n

Este cap√≠tulo cubre dos pilares fundamentales de arquitecturas de microservicios modernas:

### ‚úÖ Patr√≥n SAGA
- Permite transacciones distribuidas sin bloqueos
- Mantiene alta disponibilidad mediante compensaciones
- Es la evoluci√≥n natural de arquitecturas monol√≠ticas a microservicios

### ‚úÖ Redis Cache
- Optimiza rendimiento reduciendo latencia 10-100x
- Reduce carga en bases de datos primarias
- Es esencial para aplicaciones de alta escala

### üéØ Key Takeaways

1. **No existe consistencia fuerte gratis en sistemas distribuidos** ‚Üí Elige el nivel apropiado para cada caso
2. **Las compensaciones son tan importantes como las operaciones** ‚Üí Dise√±a ambas desde el inicio
3. **El cache es una optimizaci√≥n, no la fuente de verdad** ‚Üí La BD siempre es autoritativa
4. **Monitoring es crucial** ‚Üí No puedes mejorar lo que no mides
5. **Empieza simple, escala cuando sea necesario** ‚Üí No sobre-ingenierices desde el inicio

### üöÄ Siguiente Nivel

Para profundizar, considera implementar:
- Event Sourcing para auditor√≠a completa
- CQRS para separar lecturas y escrituras
- Distributed Tracing con OpenTelemetry
- Chaos Engineering para probar resiliencia
